<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Paper Designer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useMemo } = React;

        const GradientPaperDesigner = () => {
            const [paperSize, setPaperSize] = useState('letter');
            const [dpi, setDpi] = useState(150);
            const [gradientPoints, setGradientPoints] = useState([]);
            const [showColorPicker, setShowColorPicker] = useState(false);
            const [showPointEditor, setShowPointEditor] = useState(false);
            const [currentPoint, setCurrentPoint] = useState(null);
            const [selectedColor, setSelectedColor] = useState('#ff0000');
            const [selectedPointIndex, setSelectedPointIndex] = useState(null);
            const [draggingIndex, setDraggingIndex] = useState(null);
            const [needsRedraw, setNeedsRedraw] = useState(0);
            const svgRef = useRef(null);
            const canvasRef = useRef(null);
            const rafRef = useRef(null);

            const paperSizes = {
                letter: { width: 8.5, height: 11, unit: 'in' },
                a4: { width: 210, height: 297, unit: 'mm' },
                legal: { width: 8.5, height: 14, unit: 'in' },
                tabloid: { width: 11, height: 17, unit: 'in' }
            };

            const dpiOptions = [72, 150, 300, 600];

            const convertToPixels = (size) => {
                if (size.unit === 'in') {
                    return {
                        width: size.width * dpi,
                        height: size.height * dpi
                    };
                } else {
                    return {
                        width: (size.width / 25.4) * dpi,
                        height: (size.height / 25.4) * dpi
                    };
                }
            };

            const dimensions = useMemo(() => convertToPixels(paperSizes[paperSize]), [paperSize, dpi]);
            const scale = useMemo(() => Math.min(600 / dimensions.width, 700 / dimensions.height), [dimensions]);
            const displayWidth = dimensions.width * scale;
            const displayHeight = dimensions.height * scale;

            // Use lower resolution for preview, full resolution for export
            const previewScale = 0.5;
            const previewWidth = Math.floor(dimensions.width * previewScale);
            const previewHeight = Math.floor(dimensions.height * previewScale);

            const generateGradient = (width, height, useFullResolution = false) => {
                if (gradientPoints.length === 0) return null;
                
                const canvas = canvasRef.current || document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;
                
                const scaleAdjust = useFullResolution ? 1 : previewScale;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let totalWeight = 0;
                        let r = 0, g = 0, b = 0;
                        
                        const actualX = x / scaleAdjust;
                        const actualY = y / scaleAdjust;
                        
                        for (let i = 0; i < gradientPoints.length; i++) {
                            const point = gradientPoints[i];
                            const dx = actualX - point.x;
                            const dy = actualY - point.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            const radius = point.radius || 100;
                            const strength = point.strength || 1.0;
                            const falloff = point.falloff || 2.0;
                            
                            const normalizedDist = distance / radius;
                            const weight = strength / Math.pow(normalizedDist + 0.1, falloff);
                            
                            totalWeight += weight;
                            
                            const color = point.color;
                            const rgb = {
                                r: parseInt(color.slice(1, 3), 16),
                                g: parseInt(color.slice(3, 5), 16),
                                b: parseInt(color.slice(5, 7), 16)
                            };
                            
                            r += rgb.r * weight;
                            g += rgb.g * weight;
                            b += rgb.b * weight;
                        }
                        
                        const idx = (y * width + x) * 4;
                        data[idx] = r / totalWeight;
                        data[idx + 1] = g / totalWeight;
                        data[idx + 2] = b / totalWeight;
                        data[idx + 3] = 255;
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                return canvas.toDataURL();
            };

            const gradientImage = useMemo(() => {
                if (gradientPoints.length === 0) return null;
                return generateGradient(previewWidth, previewHeight, false);
            }, [gradientPoints, previewWidth, previewHeight, needsRedraw]);

            useEffect(() => {
                if (!canvasRef.current) {
                    canvasRef.current = document.createElement('canvas');
                }
            }, []);

            const handlePaperClick = (e) => {
                if (draggingIndex !== null) return;
                
                const svg = svgRef.current;
                const rect = svg.getBoundingClientRect();
                const x = ((e.clientX - rect.left) / displayWidth) * dimensions.width;
                const y = ((e.clientY - rect.top) / displayHeight) * dimensions.height;
                
                const clickedPointIndex = gradientPoints.findIndex(point => {
                    const dx = x - point.x;
                    const dy = y - point.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < 30;
                });

                if (clickedPointIndex !== -1) {
                    setSelectedPointIndex(clickedPointIndex);
                    setShowPointEditor(true);
                } else {
                    setCurrentPoint({ x, y });
                    setShowColorPicker(true);
                }
            };

            const handleEdgeClick = (edge) => {
                let x, y;
                switch(edge) {
                    case 'top':
                        x = dimensions.width / 2;
                        y = 0;
                        break;
                    case 'bottom':
                        x = dimensions.width / 2;
                        y = dimensions.height;
                        break;
                    case 'left':
                        x = 0;
                        y = dimensions.height / 2;
                        break;
                    case 'right':
                        x = dimensions.width;
                        y = dimensions.height / 2;
                        break;
                }
                setCurrentPoint({ x, y });
                setShowColorPicker(true);
            };

            const addGradientPoint = () => {
                if (currentPoint) {
                    setGradientPoints([...gradientPoints, { 
                        ...currentPoint, 
                        color: selectedColor,
                        radius: 100,
                        strength: 1.0,
                        falloff: 2.0
                    }]);
                    setShowColorPicker(false);
                    setCurrentPoint(null);
                }
            };

            const updatePointProperty = (property, value) => {
                if (selectedPointIndex !== null) {
                    const updated = [...gradientPoints];
                    updated[selectedPointIndex] = {
                        ...updated[selectedPointIndex],
                        [property]: value
                    };
                    setGradientPoints(updated);
                }
            };

            const deletePoint = () => {
                if (selectedPointIndex !== null) {
                    const updated = gradientPoints.filter((_, idx) => idx !== selectedPointIndex);
                    setGradientPoints(updated);
                    setShowPointEditor(false);
                    setSelectedPointIndex(null);
                }
            };

            const handleMouseDown = (e, index) => {
                e.stopPropagation();
                setDraggingIndex(index);
            };

            const handleMouseMove = (e) => {
                if (draggingIndex === null) return;
                
                if (rafRef.current) {
                    cancelAnimationFrame(rafRef.current);
                }
                
                rafRef.current = requestAnimationFrame(() => {
                    const svg = svgRef.current;
                    const rect = svg.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / displayWidth) * dimensions.width;
                    const y = ((e.clientY - rect.top) / displayHeight) * dimensions.height;
                    
                    const updated = [...gradientPoints];
                    updated[draggingIndex] = {
                        ...updated[draggingIndex],
                        x: Math.max(0, Math.min(dimensions.width, x)),
                        y: Math.max(0, Math.min(dimensions.height, y))
                    };
                    setGradientPoints(updated);
                });
            };

            const handleMouseUp = () => {
                setDraggingIndex(null);
                setNeedsRedraw(prev => prev + 1);
            };

            useEffect(() => {
                if (draggingIndex !== null) {
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);
                    return () => {
                        window.removeEventListener('mousemove', handleMouseMove);
                        window.removeEventListener('mouseup', handleMouseUp);
                        if (rafRef.current) {
                            cancelAnimationFrame(rafRef.current);
                        }
                    };
                }
            }, [draggingIndex]);

            const downloadPNG = () => {
                const dataUrl = generateGradient(dimensions.width, dimensions.height, true);
                const link = document.createElement('a');
                link.download = `gradient-paper-${paperSize}-${dpi}dpi.png`;
                link.href = dataUrl;
                link.click();
            };

            const downloadSVG = () => {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = dimensions.width;
                tempCanvas.height = dimensions.height;
                const dataUrl = generateGradient(dimensions.width, dimensions.height, true);
                
                const svgContent = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="${dimensions.width}" height="${dimensions.height}">
                    <image width="${dimensions.width}" height="${dimensions.height}" xlink:href="${dataUrl}"/>
                </svg>`;
                
                const blob = new Blob([svgContent], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `gradient-paper-${paperSize}-${dpi}dpi.svg`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            };

            const selectedPoint = selectedPointIndex !== null ? gradientPoints[selectedPointIndex] : null;

            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 to-slate-800 text-white p-8">
                    <div className="max-w-7xl mx-auto">

                        
                        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                            <div className="lg:col-span-1 space-y-6">
                                <div className="bg-slate-800/50 backdrop-blur rounded-xl p-6 border border-slate-700">
                                    <h2 className="text-xl font-semibold mb-4">Settings</h2>
                                    
                                    <div className="space-y-4">
                                        <div>
                                            <label className="block text-sm font-medium mb-2">Paper Size</label>
                                            <select 
                                                value={paperSize}
                                                onChange={(e) => setPaperSize(e.target.value)}
                                                className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                                            >
                                                <option value="letter">Letter (8.5" × 11")</option>
                                                <option value="a4">A4 (210mm × 297mm)</option>
                                                <option value="legal">Legal (8.5" × 14")</option>
                                                <option value="tabloid">Tabloid (11" × 17")</option>
                                            </select>
                                        </div>
                                        
                                        <div>
                                            <label className="block text-sm font-medium mb-2">DPI</label>
                                            <select 
                                                value={dpi}
                                                onChange={(e) => setDpi(Number(e.target.value))}
                                                className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                                            >
                                                {dpiOptions.map(d => (
                                                    <option key={d} value={d}>{d} DPI</option>
                                                ))}
                                            </select>
                                        </div>
                                        
                                        <div className="pt-4 border-t border-slate-700">
                                            <p className="text-sm text-slate-400 mb-2">
                                                Dimensions: {dimensions.width.toFixed(0)} × {dimensions.height.toFixed(0)} px
                                            </p>
                                        </div>
                                    </div>
                                </div>

                                <div className="bg-slate-800/50 backdrop-blur rounded-xl p-6 border border-slate-700">
                                    <h2 className="text-xl font-semibold mb-4">Edge Points</h2>
                                    <div className="grid grid-cols-2 gap-2">
                                        <button onClick={() => handleEdgeClick('top')} className="bg-blue-600 hover:bg-blue-700 rounded-lg px-4 py-2 transition">Top</button>
                                        <button onClick={() => handleEdgeClick('bottom')} className="bg-blue-600 hover:bg-blue-700 rounded-lg px-4 py-2 transition">Bottom</button>
                                        <button onClick={() => handleEdgeClick('left')} className="bg-blue-600 hover:bg-blue-700 rounded-lg px-4 py-2 transition">Left</button>
                                        <button onClick={() => handleEdgeClick('right')} className="bg-blue-600 hover:bg-blue-700 rounded-lg px-4 py-2 transition">Right</button>
                                    </div>
                                </div>

                                <div className="bg-slate-800/50 backdrop-blur rounded-xl p-6 border border-slate-700">
                                    <h2 className="text-xl font-semibold mb-4">Actions</h2>
                                    <div className="space-y-2">
                                        <button 
                                            onClick={downloadPNG}
                                            disabled={gradientPoints.length === 0}
                                            className="w-full bg-green-600 hover:bg-green-700 disabled:bg-slate-700 disabled:cursor-not-allowed rounded-lg px-4 py-3 transition flex items-center justify-center gap-2"
                                        >
                                            <span>⬇</span>
                                            Download PNG
                                        </button>
                                        <button 
                                            onClick={downloadSVG}
                                            disabled={gradientPoints.length === 0}
                                            className="w-full bg-purple-600 hover:bg-purple-700 disabled:bg-slate-700 disabled:cursor-not-allowed rounded-lg px-4 py-3 transition flex items-center justify-center gap-2"
                                        >
                                            <span>⬇</span>
                                            Download SVG
                                        </button>
                                        <button 
                                            onClick={() => setGradientPoints([])}
                                            disabled={gradientPoints.length === 0}
                                            className="w-full bg-red-600 hover:bg-red-700 disabled:bg-slate-700 disabled:cursor-not-allowed rounded-lg px-4 py-3 transition"
                                        >
                                            Clear All Points
                                        </button>
                                    </div>
                                    <p className="text-sm text-slate-400 mt-4">
                                        {gradientPoints.length} gradient point{gradientPoints.length !== 1 ? 's' : ''} added
                                    </p>
                                </div>
                            </div>

                            <div className="lg:col-span-2">
                                <div className="bg-slate-800/50 backdrop-blur rounded-xl p-6 border border-slate-700">
                                    <h2 className="text-xl font-semibold mb-4">Canvas</h2>
                                    <p className="text-sm text-slate-400 mb-4">Click to add points • Click and drag to move • Click on a point to edit</p>
                                    
                                    <div className="flex justify-center">
                                        <svg
                                            ref={svgRef}
                                            width={displayWidth}
                                            height={displayHeight}
                                            viewBox={`0 0 ${dimensions.width} ${dimensions.height}`}
                                            className="border-2 border-slate-600 rounded-lg cursor-crosshair shadow-2xl bg-white"
                                            onClick={handlePaperClick}
                                        >
                                            {gradientImage && (
                                                <image 
                                                    href={gradientImage} 
                                                    width={dimensions.width} 
                                                    height={dimensions.height}
                                                    preserveAspectRatio="none"
                                                />
                                            )}
                                            {gradientPoints.map((point, idx) => (
                                                <g key={idx}>
                                                    <circle
                                                        cx={point.x}
                                                        cy={point.y}
                                                        r={(point.radius || 100) / 5}
                                                        fill={point.color}
                                                        fillOpacity="0.2"
                                                        stroke="none"
                                                    />
                                                    <circle
                                                        cx={point.x}
                                                        cy={point.y}
                                                        r={15 / scale}
                                                        fill={point.color}
                                                        stroke="white"
                                                        strokeWidth={3 / scale}
                                                        className="cursor-move"
                                                        onMouseDown={(e) => handleMouseDown(e, idx)}
                                                        style={{ cursor: 'move' }}
                                                    />
                                                </g>
                                            ))}
                                        </svg>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    {showColorPicker && (
                        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50">
                            <div className="bg-slate-800 rounded-xl p-8 border border-slate-700 shadow-2xl">
                                <h3 className="text-2xl font-semibold mb-4">Choose Color</h3>
                                <input
                                    type="color"
                                    value={selectedColor}
                                    onChange={(e) => setSelectedColor(e.target.value)}
                                    className="w-64 h-32 rounded-lg cursor-pointer"
                                />
                                <div className="flex gap-4 mt-6">
                                    <button
                                        onClick={addGradientPoint}
                                        className="flex-1 bg-blue-600 hover:bg-blue-700 rounded-lg px-6 py-3 transition font-semibold"
                                    >
                                        Add Point
                                    </button>
                                    <button
                                        onClick={() => {
                                            setShowColorPicker(false);
                                            setCurrentPoint(null);
                                        }}
                                        className="flex-1 bg-slate-700 hover:bg-slate-600 rounded-lg px-6 py-3 transition"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {showPointEditor && selectedPoint && (
                        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50">
                            <div className="bg-slate-800 rounded-xl p-8 border border-slate-700 shadow-2xl max-w-md w-full">
                                <div className="flex items-center justify-between mb-6">
                                    <h3 className="text-2xl font-semibold flex items-center gap-2">
                                        <span>⚙</span>
                                        Edit Point
                                    </h3>
                                    <button
                                        onClick={() => {
                                            setShowPointEditor(false);
                                            setSelectedPointIndex(null);
                                            setNeedsRedraw(prev => prev + 1);
                                        }}
                                        className="text-slate-400 hover:text-white transition text-2xl"
                                    >
                                        ✕
                                    </button>
                                </div>

                                <div className="space-y-6">
                                    <div>
                                        <label className="block text-sm font-medium mb-2">Color</label>
                                        <input
                                            type="color"
                                            value={selectedPoint.color}
                                            onChange={(e) => updatePointProperty('color', e.target.value)}
                                            className="w-full h-20 rounded-lg cursor-pointer"
                                        />
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium mb-2">
                                            Radius: {selectedPoint.radius?.toFixed(0) || 100}
                                        </label>
                                        <input
                                            type="range"
                                            min="10"
                                            max="500"
                                            value={selectedPoint.radius || 100}
                                            onChange={(e) => updatePointProperty('radius', Number(e.target.value))}
                                            className="w-full"
                                        />
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium mb-2">
                                            Strength: {selectedPoint.strength?.toFixed(2) || 1.0}
                                        </label>
                                        <input
                                            type="range"
                                            min="0.1"
                                            max="3"
                                            step="0.1"
                                            value={selectedPoint.strength || 1.0}
                                            onChange={(e) => updatePointProperty('strength', Number(e.target.value))}
                                            className="w-full"
                                        />
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium mb-2">
                                            Falloff: {selectedPoint.falloff?.toFixed(2) || 2.0}
                                        </label>
                                        <input
                                            type="range"
                                            min="0.5"
                                            max="5"
                                            step="0.1"
                                            value={selectedPoint.falloff || 2.0}
                                            onChange={(e) => updatePointProperty('falloff', Number(e.target.value))}
                                            className="w-full"
                                        />
                                    </div>

                                    <div className="pt-4 border-t border-slate-700">
                                        <button
                                            onClick={deletePoint}
                                            className="w-full bg-red-600 hover:bg-red-700 rounded-lg px-6 py-3 transition font-semibold"
                                        >
                                            Delete Point
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        ReactDOM.render(<GradientPaperDesigner />, document.getElementById('root'));
    </script>
</body>
</html>