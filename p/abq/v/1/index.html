<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>INP Surface Parser â€¢ Viewer â€¢ DATâ†’CSV â€¢ Deformed surfaces â€¢ Volumes â€¢ Amplitudes</title>
<style>
  :root {
    --bg:#0b1220; --card:#121b2f; --ink:#e9f0ff; --muted:#9cb0d6; --accent:#7cc0ff; --accent2:#9ff0a8;
    --panel:#ffffff; --panelInk:#0b1220;
    --dat-bg:#0f1220; --dat-card:#171a2b; --dat-ink:#e6e8ef; --dat-muted:#aeb3c2; --dat-accent:#6cd1ff;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    color:var(--ink); background:linear-gradient(180deg,#0a1020,#0e1630 40%,#0a1020);
    display:flex; flex-direction:column;
  }
  header{padding:18px 20px 0; display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  h1{font-size:20px; margin:0 8px 0 0; font-weight:700}
  .sub{color:var(--muted); font-size:14px}

  /* 3 columns â€“ make viewer ~30% wider than before */
  .page{
    display:grid; grid-template-columns: 1.1fr 1.7fr 1.1fr; gap:14px;
    padding:14px 16px 18px; height:calc(100% - 64px); max-width:1920px; margin:0 auto;
  }
  .col{min-width:340px; overflow:auto}

  .drops{display:grid; grid-template-columns:repeat(auto-fit,minmax(280px,1fr)); gap:12px}
  .drop{border:2px dashed #2b3f6b; border-radius:16px; padding:18px; text-align:center;
        background:rgba(18,27,47,.6); backdrop-filter: blur(3px)}
  .drop.drag{border-color:var(--accent); box-shadow:0 0 0 3px rgba(124,192,255,.2) inset}
  .btn{cursor:pointer; background:var(--accent); color:#041428; padding:9px 12px; border:none; border-radius:12px; font-weight:700}
  .btn.green{background:var(--accent2); color:#06210a}
  .btn.softer{background:#5da8e7}
  .btn:disabled{opacity:.5; cursor:not-allowed}

  .grid{display:grid; grid-template-columns:repeat(auto-fit,minmax(320px,1fr)); gap:12px; margin-top:12px}
  .card{background:var(--card); border:1px solid #223055; border-radius:16px; padding:12px 12px 14px}
  .card h2{margin:2px 0 6px; font-size:16px}
  .kv{font-size:13px; color:var(--muted); margin:2px 0}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace}
  .surf{display:flex; flex-direction:column; gap:8px; background:#0f1a33; border:1px solid #23325a;
        border-radius:12px; padding:10px; margin-top:8px}
  .row{display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap}
  .muted{color:var(--muted)} .tiny{font-size:12px}
  .btnbar{display:flex; gap:8px; flex-wrap:wrap}
  .amp{background:#0f1a33; border:1px solid #23325a; border-radius:12px; padding:10px; margin-top:8px}

  .viewer{background:var(--panel); color:var(--panelInk); border-radius:16px; padding:12px; display:flex; flex-direction:column; gap:8px}
  .viewer h3{margin:0 0 4px 2px; font-size:16px}
  .canvasWrap{flex:1 1 auto; border:1px solid #d7dbe7; border-radius:12px; position:relative; background:#fff; min-height:260px}
  canvas{display:block; width:100%; height:100%; cursor:grab}
  canvas.dragging{cursor:grabbing}
  .hud{position:absolute; left:8px; top:8px; padding:4px 8px; background:rgba(255,255,255,.85);
       border:1px solid #cbd5e1; border-radius:8px; font-size:12px; color:#0b1220}

  .controls{display:flex; gap:10px; align-items:center; flex-wrap:wrap; border:1px solid #e3e7ef;
            background:#f9fbff; border-radius:10px; padding:6px 8px}
  .controls label{font-size:12px; color:#334}
  .ctrlVal{min-width:48px; text-align:right; font-variant-numeric:tabular-nums}
  .sep{width:1px; background:#d9dfeb; height:20px}

  /* Right column (DAT + reference point & volumes) */
  .datCol{background:var(--dat-bg); color:var(--dat-ink); border-radius:16px; padding:12px; display:flex; flex-direction:column; gap:10px; border:1px solid #232742}
  .datCard{background:var(--dat-card); border:1px solid #232742; border-radius:14px; padding:14px}
  .datTitle{margin:0 0 4px; font-size:16px}
  .datSmall{color:var(--dat-muted); margin:0 0 6px; font-size:13px}
  .datDrop{display:flex; align-items:center; justify-content:center; gap:10px; min-height:120px;
           border:2px dashed #2b3152; border-radius:14px; background:#121530; cursor:pointer; transition:.2s}
  .datDrop:hover{border-color:#3a426e}
  .datDrop.drag{border-color:var(--dat-accent); background:#121a3a}
  .datControls{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
  .datBtn{background:#273058; border:1px solid #37407a; color:var(--dat-ink); padding:9px 12px; border-radius:12px; cursor:pointer}
  .datBtn[disabled]{opacity:.5; cursor:not-allowed}
  .datTags{display:flex; gap:10px; flex-wrap:wrap; margin:8px 0 4px}
  .datTag{background:#1b2040; border:1px solid #2a2f5e; border-radius:999px; padding:4px 10px; color:#cfd3e6; font-size:12px}
  .datLog{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#0c0f22; border:1px solid #1a1f3f; border-radius:12px; padding:10px; height:140px; overflow:auto; white-space:pre-wrap}
  .datTableWrap{border:1px solid #1a1f3f; border-radius:12px; overflow:auto; max-height:240px; background:#0c0f22}
  .datTable{width:max(640px,100%); border-collapse:collapse}
  .datTable th,.datTable td{padding:8px; border-bottom:1px solid #262b4a; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; white-space:nowrap}
  .datTable th{color:#c9d3ff; text-align:left}
  .rightStatus{margin-left:auto; color:#92f0c5}
  a.datLink{color:#9be0ff; text-decoration:none; border-bottom:1px dotted #9be0ff}

  /* ref controls moved to right column */
  .refPanel{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .refPanel input, .refPanel select{width:110px; padding:6px 8px; border:1px solid #ccd6ea; border-radius:8px}
  .pill{background:#eef3ff; border:1px solid #d7e0f6; padding:6px 8px; border-radius:10px; font-size:12px; color:#445}

  .volTableWrap{border:1px solid #dfe6f6; border-radius:10px; overflow:auto; max-height:260px; background:#fff}
  .volTable{width:max(560px,100%); border-collapse:collapse}
  .volTable th,.volTable td{padding:6px 8px; border-bottom:1px solid #e9eefb; color:#102}
</style>
</head>
<body>
  <header>
    <h1>INP Surface Parser</h1>
    <span class="sub">Assembly & Single-Part â€¢ Viewer â€¢ DATâ†’CSV â€¢ Deformed surfaces â€¢ Volumes â€¢ Amplitudes</span>
  </header>

  <div class="page">
    <!-- Column 1: INP (assembly + single) + Amplitudes -->
    <div class="col">
      <div class="drops">
        <div id="dropAsm" class="drop">
          <p style="margin:2px 0 6px"><b>Assembly INP</b> (with <span class="mono">*Part</span> blocks)</p>
          <p><label class="btn" for="fileAsm">Choose file</label></p>
          <input id="fileAsm" type="file" accept=".inp,.txt" style="display:none" />
          <p class="tiny muted">Comments starting with <span class="mono">**</span> are removed.</p>
        </div>
        <div id="dropSingle" class="drop">
          <p style="margin:2px 0 6px"><b>Single-Part INP</b> (no <span class="mono">*Part</span> / <span class="mono">*End Part</span>)</p>
          <p><label class="btn" for="fileSingle">Choose file</label></p>
          <input id="fileSingle" type="file" accept=".inp,.txt" style="display:none" />
          <p class="tiny muted">Parses global <span class="mono">*NODE</span>, <span class="mono">*ELEMENT</span>, <span class="mono">*Elset</span>, <span class="mono">*Surface</span>, <span class="mono">*AMPLITUDE</span>.</p>
        </div>
      </div>

      <!-- amplitudes appear here -->
      <section id="ampOut"></section>

      <!-- parts & surfaces -->
      <section id="out"></section>
    </div>

    <!-- Column 2: Viewer (wider) -->
    <div class="col viewer">
      <h3 id="vizTitle">Surface viewer</h3>
      <div class="tiny" id="vizMeta" style="margin:0 2px 4px;color:#465060"></div>
      <!-- Deform controls stay with the viewer -->
      <div class="controls" id="deformControls" style="display:none">
        <label>Increment:
          <input id="incSlider" type="range" min="1" max="1" step="1" value="1" style="vertical-align:middle">
          <span class="ctrlVal" id="incLabel">1</span>
        </label>
        <div class="sep"></div>
        <label>Scale:
          <input id="scaleSlider" type="range" min="0" max="5" step="0.05" value="1">
          <span class="ctrlVal" id="scaleLabel">1.00Ã—</span>
        </label>
        <div class="sep"></div>
        <span id="timeLabel" class="tiny" style="color:#334"></span>
      </div>

      <div class="canvasWrap" id="canvasWrap">
        <canvas id="viz"></canvas>
        <div class="hud">Drag: rotate â€¢ Wheel: zoom â€¢ Shift+Drag: pan â€¢ Dbl-click: reset</div>
      </div>
    </div>

    <!-- Column 3: DAT parser + Reference point & Volume series -->
    <div class="col datCol">
      <div class="datCard">
        <h3 class="datTitle">Abaqus DAT â†’ CSV (Increment Node Output)</h3>
        <p class="datSmall">Exports CSV and powers <b>Deform</b> & volume series:
          <code>increment,time_increment,node,U1,U2,U3</code>. Times are accumulated to total time.</p>
        <div id="datDrop" class="datDrop" tabindex="0" role="button" aria-label="Drop DAT file here or click to choose">
          <span>ðŸ“„ Drop <em>.dat</em> file here or click to choose</span>
          <input id="datFile" type="file" accept=".dat,text/plain" hidden />
        </div>
        <div class="datControls">
          <button id="datParse" class="datBtn" disabled>Parse DAT â†’ CSV</button>
          <a id="datDownload" class="datBtn datLink" style="display:none" download="node_displacements_by_increment.csv">â¬‡ Download CSV</a>
          <button id="datClear" class="datBtn">Clear</button>
          <span id="datStatus" class="rightStatus"></span>
        </div>
        <div class="datTags">
          <span id="datFname" class="datTag" style="display:none"></span>
          <span id="datFsize" class="datTag" style="display:none"></span>
          <span id="datStats" class="datTag" style="display:none"></span>
        </div>
        <div class="datLog" id="datLog" aria-live="polite"></div>
        <div class="datTableWrap" id="datTableWrap" style="display:none">
          <table id="datPreview" class="datTable">
            <thead><tr><th>increment</th><th>Î”t</th><th>total_t</th><th>node</th><th>U1</th><th>U2</th><th>U3</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <!-- Reference point & volume are now here under DAT -->
      <div class="datCard">
        <h3 class="datTitle">Reference point â€¢ Volumes â€¢ Pâ€“V</h3>
        <div class="refPanel">
          <span class="pill">Ref point (x, y, z)</span>
          <input id="refX" type="number" step="any" placeholder="x">
          <input id="refY" type="number" step="any" placeholder="y">
          <input id="refZ" type="number" step="any" placeholder="z">
          <button id="setRef" class="datBtn">Set point</button>
          <button id="togglePreview" class="datBtn" disabled>Check volume</button>
<!-- Put this next to the Check volume button -->
<label class="pill" style="display:flex;align-items:center;gap:6px">
  <input id="signedVol" type="checkbox" checked>
  Signed volume
</label>
        </div>
        <div class="refPanel" style="margin-top:8px">
          <span class="pill">Amplitude for Pâ€“V</span>
          <select id="ampSelect">
            <option value="">(none)</option>
          </select>
          <button id="runSeries" class="datBtn" disabled>Compute volume series</button>
          <a id="volCsv" class="datBtn datLink" style="display:none" download="volume_series.csv">â¬‡ Download CSV</a>
        </div>
        <div id="volTableWrap" class="volTableWrap" style="display:none; margin-top:10px">
          <table id="volTable" class="volTable">
            <thead><tr>
              <th>increment</th><th>Î”t</th><th>total_t</th><th>volume</th><th>amplitude</th>
            </tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

<script>
/* ======================= INP parsing (nodes/elements/surfaces + amplitudes) ======================= */
function cleanLines(text){ return text.replace(/\r/g,'').split('\n').filter(line=>!/^\s*\*\*\s*/.test(line)); }
function parseCsvTokens(chunk){ return chunk.replace(/[^0-9,.\s\-+eE]/g,' ').split(/[, \t\n]+/).filter(t=>t.length>0); }
function toInts(tokens){ return tokens.map(x=>parseInt(x,10)).filter(Number.isFinite); }
function download(filename, text, mime='text/csv'){ const b=new Blob([text],{type:mime}); const u=URL.createObjectURL(b); const a=document.createElement('a'); a.href=u; a.download=filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(u); }
const FACE_MAP={ 'S1':n=>[n[0],n[1],n[2]], 'S2':n=>[n[0],n[3],n[1]], 'S3':n=>[n[1],n[3],n[2]], 'S4':n=>[n[2],n[3],n[0]] };

function parseAmplitudes(lines){
  const amps=[]; for(let i=0;i<lines.length;i++){
    const l=lines[i].trim();
    if(/^\*amplitude\b/i.test(l)){
      const name=/name\s*=\s*([^,\s]+)/i.exec(l)?.[1]||`Amplitude_${amps.length+1}`;
      i++;
      const pairs=[];
      while(i<lines.length){
        const s=lines[i].trim(); if(s.startsWith('*') || s==='') break;
        const toks=parseCsvTokens(s).map(Number).filter(v=>Number.isFinite(v));
        for(let k=0;k+1<toks.length;k+=2){ pairs.push([toks[k], toks[k+1]]); }
        i++;
      }
      amps.push({name, pairs});
      i--; // step back one because the for loop will increment
    }
  }
  return amps;
}

function parseWithin(lines, iStart, iEnd){
  const data={nodes:new Map(), elements:new Map(), elsets:new Map(), surfaces:[]}; let i=iStart;
  while(i<iEnd){
    const cur=lines[i].trim();

    if(/^\*node\b/i.test(cur)){ i++;
      while(i<iEnd){ const s=lines[i].trim(); if(s.startsWith('*')||!s.length) break;
        const t=parseCsvTokens(s); if(t.length>=4){ const id=parseInt(t[0],10);
          const x=parseFloat(t[1]),y=parseFloat(t[2]),z=parseFloat(t[3]); if(Number.isFinite(id)) data.nodes.set(id,[x,y,z]); }
        i++; } continue; }

    if(/^\*element\b/i.test(cur)){ i++;
      while(i<iEnd){ const s=lines[i].trim(); if(s.startsWith('*')||!s.length) break;
        const nums=toInts(parseCsvTokens(s)); if(nums.length>=5){ const eid=nums[0]; const nodes=nums.slice(1,5); data.elements.set(eid,nodes); }
        i++; } continue; }

    if(/^\*elset\b/i.test(cur)){ const nm=/elset\s*=\s*([^,\s]+)/i.exec(cur); const setName=nm?nm[1]:`ELSET_${data.elsets.size+1}`; const ids=[]; i++;
      while(i<iEnd){ const s=lines[i].trim(); if(s.startsWith('*')||!s.length) break; ids.push(...toInts(parseCsvTokens(s))); i++; }
      data.elsets.set(setName,new Set(ids)); continue; }

    if(/^\*surface\b/i.test(cur) && /type\s*=\s*element/i.test(cur)){ const sm=/name\s*=\s*([^,\s]+)/i.exec(cur);
      const surfName=sm?sm[1]:`Surf_${data.surfaces.length+1}`; const items=[]; i++;
      while(i<iEnd){ const s=lines[i].trim(); if(s.startsWith('*')||!s.length) break;
        const m=s.split(/[, \t]+/).filter(Boolean); if(m.length>=2){ const elsetRef=m[0]; const face=m[1].toUpperCase(); if(/^S[1-4]$/.test(face)) items.push({elset:elsetRef,face}); } i++; }
      data.surfaces.push({name:surfName,items}); continue; }

    i++;
  }
  return data;
}
function parseAssembly(lines){ const parts=[]; for(let i=0;i<lines.length;i++){ const l=lines[i].trim();
  if(/^\*part\b/i.test(l)){ const name=/name\s*=\s*([^,\s]+)/i.exec(l)?.[1]||`Part_${parts.length+1}`; let j=i+1; while(j<lines.length && !/^\*end\s+part\b/i.test(lines[j].trim())) j++;
    const block=parseWithin(lines,i+1,j); parts.push({name,...block}); if(j<lines.length) i=j; } } return parts; }
function parseSingle(lines){ const block=parseWithin(lines,0,lines.length); return [{name:'global',...block}]; }

function buildCombined(part, surface){
  const seenEF=new Set(); const faceRows=[]; const nodesUsed=new Set();
  for(const item of surface.items){ const set=part.elsets.get(item.elset); const pick=FACE_MAP[item.face];
    if(!set||!pick) continue;
    for(const eid of set){
      const key=eid+'|'+item.face; if(seenEF.has(key)) continue;
      const nodes=part.elements.get(eid); if(!nodes||nodes.length<4) continue;
      const [a,b,c]=pick(nodes);
      faceRows.push([part.name, surface.name, eid, a,b,c]);
      nodesUsed.add(a); nodesUsed.add(b); nodesUsed.add(c);
      seenEF.add(key);
    }
  }
  faceRows.sort((A,B)=>A[2]-B[2]||A[3]-B[3]||A[4]-B[4]||A[5]-B[5]);
  const nodeRows=Array.from(nodesUsed).sort((a,b)=>a-b).map(n=>{
    const xyz=part.nodes.get(n)||[NaN,NaN,NaN];
    return [part.name, surface.name, n, ...xyz];
  });

  const facesCsv='part,surface,element,node1,node2,node3\n'+faceRows.map(r=>r.join(',')).join('\n');
  const nodesCsv='part,surface,node,x,y,z\n'+nodeRows.map(r=>r.join(',')).join('\n');
  return {facesCsv, nodesCsv, facesCount: faceRows.length, nodeCount: nodeRows.length, tris: faceRows.map(r=>r.slice(3,6)), nodeSet: new Set(nodeRows.map(r=>r[2])) };
}

/* ======================= UI render: amplitudes + parts ======================= */
const ampOut = document.getElementById('ampOut');
const out = document.getElementById('out');
let lastAmplitudes = []; // [{name, pairs:[[t,v],...]}]

setupDrop('Asm', f=>handleFile(f,true));
setupDrop('Single', f=>handleFile(f,false));
function setupDrop(suffix,onFile){ const dz=document.getElementById('drop'+suffix), inp=document.getElementById('file'+suffix);
  ['dragenter','dragover'].forEach(ev=>dz.addEventListener(ev,e=>{e.preventDefault(); e.stopPropagation(); dz.classList.add('drag');}));
  ['dragleave','drop'].forEach(ev=>dz.addEventListener(ev,e=>{e.preventDefault(); e.stopPropagation(); dz.classList.remove('drag');}));
  dz.addEventListener('drop', e=>{const f=e.dataTransfer.files[0]; if(f) onFile(f);});
  inp.addEventListener('change', e=>{const f=e.target.files[0]; if(f) onFile(f);});
}
function handleFile(file,isAssembly){
  const r=new FileReader();
  r.onload=()=>{
    const lines=cleanLines(String(r.result));
    lastAmplitudes = parseAmplitudes(lines);
    renderAmplitudes();
    let parts=isAssembly?parseAssembly(lines):parseSingle(lines);
    if(parts.length===0 && isAssembly){ parts=parseSingle(lines); }
    render(parts, file.name);
    populateAmpSelect();
  };
  r.readAsText(file);
}
function renderAmplitudes(){
  ampOut.innerHTML='';
  if(!lastAmplitudes.length) return;
  const card=document.createElement('div'); card.className='card';
  card.innerHTML = `<h2>Amplitudes</h2><div class="kv tiny">Parsed ${lastAmplitudes.length} amplitude table(s).</div>`;
  lastAmplitudes.forEach(a=>{
    const rows=a.pairs.length;
    const div=document.createElement('div'); div.className='amp';
    div.innerHTML=`<div class="row">
      <div><strong class="mono">${a.name}</strong><div class="tiny muted">${rows} rows (time,value)</div></div>
      <div class="btnbar"><button class="btn">Download CSV</button></div>
    </div>`;
    div.querySelector('button').addEventListener('click', ()=>{
      const csv='time,value\n'+a.pairs.map(p=>`${p[0]},${p[1]}`).join('\n');
      download(`${a.name}.csv`, csv);
    });
    card.appendChild(div);
  });
  ampOut.appendChild(card);
}
function render(parts, filename){
  out.innerHTML='';
  if(parts.length===0){ out.innerHTML=`<p class="muted">No parsable content found in <b>${filename}</b>.</p>`; return; }
  const grid=document.createElement('div'); grid.className='grid';
  for(const part of parts){
    const card=document.createElement('div'); card.className='card';
    card.innerHTML=`<h2>Part: <span class="mono">${part.name}</span></h2>
    <div class="kv">Nodes: <b>${part.nodes.size}</b> â€¢ Elements: <b>${part.elements.size}</b> â€¢ Elsets: <b>${part.elsets.size}</b> â€¢ Surfaces: <b>${part.surfaces.length}</b></div>
    <div class="kv tiny">Surfaces are combined across S1â€“S4 (tet corner nodes only).</div>`;
    if(part.surfaces.length===0){
      card.insertAdjacentHTML('beforeend', `<div class="surf"><div class="muted">No element-type surfaces in this part.</div></div>`);
    }
    for(const surface of part.surfaces){
      const built=buildCombined(part, surface);
      const {facesCsv,nodesCsv,facesCount,nodeCount,tris,nodeSet}=built;
      const block=document.createElement('div'); block.className='surf';
      block.innerHTML = `
        <div class="row">
          <div>
            <strong class="mono">${surface.name}</strong>
            <div class="tiny muted">Combined faces: <b>${facesCount}</b> â€¢ Unique nodes: <b>${nodeCount}</b></div>
          </div>
          <div class="btnbar">
            <button class="btn" ${facesCount===0?'disabled':''}>Download faces</button>
            <button class="btn" ${nodeCount===0?'disabled':''}>Download nodes</button>
            <button class="btn green" ${facesCount===0?'disabled':''}>Visualize</button>
            <button class="btn softer deformBtn" title="Overlay deformed mesh from DAT" disabled>Deform</button>
          </div>
        </div>`;
      const [btnFaces, btnNodes, btnViz, btnDef] = block.querySelectorAll('button');
      btnFaces.addEventListener('click', ()=>download(`${safe(part.name)}__${safe(surface.name)}__faces.csv`, facesCsv));
      btnNodes.addEventListener('click', ()=>download(`${safe(part.name)}__${safe(surface.name)}__nodes.csv`, nodesCsv));
      btnViz.addEventListener('click', ()=>{ const mesh=buildMeshForViz(part, tris); showInViewer(mesh, part.name, surface.name, {showRef:true}); currentContext={part,surface,tris,nodeSet,mesh}; disableVolumeButtons(); });
      btnDef.addEventListener('click', ()=> startDeform(part, surface, tris, nodeSet));
      card.appendChild(block);
    }
    grid.appendChild(card);
  }
  out.appendChild(grid);
  refreshDeformButtons();
}
function safe(s){ return String(s).replace(/[^\w.-]+/g,'_'); }

/* ======================= Viewer logic ======================= */
const canvas = document.getElementById('viz');
const wrap   = document.getElementById('canvasWrap');
const vizTitle = document.getElementById('vizTitle');
const vizMeta  = document.getElementById('vizMeta');
const deformControls = document.getElementById('deformControls');
const incSlider = document.getElementById('incSlider');
const incLabel  = document.getElementById('incLabel');
const scaleSlider = document.getElementById('scaleSlider');
const scaleLabel  = document.getElementById('scaleLabel');
const timeLabel   = document.getElementById('timeLabel');

const refX = document.getElementById('refX');
const refY = document.getElementById('refY');
const refZ = document.getElementById('refZ');
const setRef = document.getElementById('setRef');
const togglePreview = document.getElementById('togglePreview');
const runSeries = document.getElementById('runSeries');
const volCsv = document.getElementById('volCsv');
const volTableWrap = document.getElementById('volTableWrap');
const volTableBody = document.querySelector('#volTable tbody');
const ampSelect = document.getElementById('ampSelect');

let ctx = canvas.getContext('2d');
let CW=0,CH=0, resizeRAF=null;

const ro=new ResizeObserver(()=>{ if(resizeRAF) cancelAnimationFrame(resizeRAF);
  resizeRAF=requestAnimationFrame(()=>{
    const rect=wrap.getBoundingClientRect();
    const dpr=Math.min(2, window.devicePixelRatio||1);
    const w=Math.max(200, Math.floor(rect.width*dpr));
    const h=Math.max(200, Math.floor(rect.height*dpr));
    if(w!==CW || h!==CH){ CW=w; CH=h; canvas.width=CW; canvas.height=CH; draw(); }
  });
});
ro.observe(wrap);

function buildMeshForViz(part, faceTriples){
  const ids=new Set(); faceTriples.forEach(t=>t.forEach(n=>ids.add(n)));
  const id2i=new Map(); const verts=[];
  Array.from(ids).forEach((nid,idx)=>{ id2i.set(nid,idx); const xyz=part.nodes.get(nid)||[0,0,0]; verts.push({id:nid,x:xyz[0],y:xyz[1],z:xyz[2]}); });
  const faces=faceTriples.map(t=>t.map(n=>id2i.get(n)));
  return {verts, faces, id2i};
}
const state={
  rx:0.6, ry:-0.8, tx:0, ty:0, zoom:1.0, cx:0, cy:0, cz:0, scale:1,
  verts:[], faces:[], baseVerts:[],
  overlayVerts:null, overlayFaces:null,
  showRef:false, refPoint:null, showPreview:false,
};
let drag=null;

canvas.addEventListener('mousedown', e=>{
  const r=canvas.getBoundingClientRect();
  drag={x:e.clientX-r.left, y:e.clientY-r.top, rx:state.rx, ry:state.ry, tx:state.tx, ty:state.ty, shift:e.shiftKey};
  canvas.classList.add('dragging');
});
window.addEventListener('mouseup', ()=>{ drag=null; canvas.classList.remove('dragging'); });
window.addEventListener('mousemove', e=>{
  if(!drag) return;
  const r=canvas.getBoundingClientRect(); const nx=e.clientX-r.left, ny=e.clientY-r.top; const dx=nx-drag.x, dy=ny-drag.y;
  if(e.shiftKey || drag.shift){ state.tx = drag.tx + dx/(120*state.zoom); state.ty = drag.ty + dy/(120*state.zoom); }
  else { state.ry = drag.ry + dx*0.01; state.rx = drag.rx + dy*0.01; }
  draw();
});
canvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const k=Math.exp(-e.deltaY*0.001);
  state.zoom=Math.max(0.05, Math.min(20, state.zoom*k));
  draw();
},{passive:false});
canvas.addEventListener('dblclick', ()=>{ state.rx=0.6; state.ry=-0.8; state.tx=0; state.ty=0; state.zoom=1.0; draw(); });

function centerAndScale(verts){
  if(!verts.length) return;
  let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
  for(const v of verts){ if(!isFinite(v.x+v.y+v.z)) continue;
    if(v.x<minX)minX=v.x; if(v.y<minY)minY=v.y; if(v.z<minZ)minZ=v.z;
    if(v.x>maxX)maxX=v.x; if(v.y>maxY)maxY=v.y; if(v.z>maxZ)maxZ=v.z;
  }
  const cx=(minX+maxX)/2, cy=(minY+maxY)/2, cz=(minZ+maxZ)/2;
  const size=Math.max(maxX-minX, maxY-minY, maxZ-minZ) || 1;
  state.cx=cx; state.cy=cy; state.cz=cz;
  state.scale = 0.9 * Math.min(CW,CH) / size;
}
function showInViewer(mesh, partName, surfName,{showRef=false}={}){
  state.verts=mesh.verts; state.faces=mesh.faces;
  state.baseVerts = mesh.verts.map(v=>({x:v.x,y:v.y,z:v.z,id:v.id}));
  state.overlayVerts=null; state.overlayFaces=null;
  state.showRef=showRef;
  centerAndScale(state.verts);
  vizTitle.textContent = `Surface viewer â€” ${surfName}`;
  vizMeta.textContent  = `Part: ${partName} â€¢ Verts: ${state.verts.length} â€¢ Tris: ${state.faces.length}`;
  draw();
}
function hideDeformControls(){ deformControls.style.display='none'; }

function draw(){
  if(!ctx) return;
  ctx.clearRect(0,0,CW,CH);
  ctx.save();
  ctx.translate(CW/2, CH/2);
  ctx.scale(1, -1);

  const sinx=Math.sin(state.rx), cosx=Math.cos(state.rx);
  const siny=Math.sin(state.ry), cosy=Math.cos(state.ry);
  const proj = state.verts.map(v=>{
    let x=(v.x-state.cx), y=(v.y-state.cy), z=(v.z-state.cz);
    let y1 = y*cosx - z*sinx, z1 = y*sinx + z*cosx;
    let x2 = x*cosy + z1*siny, z2 = -x*siny + z1*cosy;
    const s = state.scale*state.zoom;
    return {x: x2*s + state.tx*CW/2, y: y1*s + state.ty*CH/2, z: z2};
  });

  const order = state.faces.map((f,idx)=>({idx, z:(proj[f[0]].z+proj[f[1]].z+proj[f[2]].z)/3})).sort((a,b)=>a.z-b.z);
  // original wireframe
  for(const o of order){
    const f=state.faces[o.idx]; const a=proj[f[0]], b=proj[f[1]], c=proj[f[2]];
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.lineTo(c.x,c.y); ctx.closePath();
    ctx.strokeStyle='rgba(90,100,120,0.85)'; ctx.lineWidth=0.75; ctx.stroke();
  }

  // overlay deformed fill if exists
  if(state.overlayVerts){
    const proj2 = state.overlayVerts.map(v=>{
      let x=(v.x-state.cx), y=(v.y-state.cy), z=(v.z-state.cz);
      let y1 = y*cosx - z*sinx, z1 = y*sinx + z*cosx;
      let x2 = x*cosy + z1*siny, z2 = -x*siny + z1*cosy;
      const s = state.scale*state.zoom;
      return {x: x2*s + state.tx*CW/2, y: y1*s + state.ty*CH/2, z: z2};
    });
    const ord2 = state.overlayFaces.map((f,idx)=>({idx, z:(proj2[f[0]].z+proj2[f[1]].z+proj2[f[2]].z)/3})).sort((a,b)=>a.z-b.z);
    for(const o of ord2){
      const f=state.overlayFaces[o.idx]; const a=proj2[f[0]], b=proj2[f[1]], c=proj2[f[2]];
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.lineTo(c.x,c.y); ctx.closePath();
      ctx.fillStyle='rgba(60,100,200,0.28)'; ctx.strokeStyle='rgba(40,80,160,0.95)'; ctx.lineWidth=1.1; ctx.fill(); ctx.stroke();
    }
  }

  // reference point + preview tethers
  if(state.refPoint){
    const rp=projectPoint(state.refPoint);
    ctx.save();
    ctx.fillStyle='rgba(210,40,40,0.95)'; ctx.strokeStyle='rgba(210,40,40,0.95)';
    ctx.beginPath(); ctx.arc(rp.x, rp.y, 3, 0, Math.PI*2); ctx.fill();
    if(state.showPreview){
      ctx.strokeStyle='rgba(210,40,40,0.35)'; ctx.lineWidth=0.6;
      for(const f of state.faces){
        const a=state.verts[f[0]], b=state.verts[f[1]], c=state.verts[f[2]];
        const cx = (a.x+b.x+c.x)/3, cy=(a.y+b.y+c.y)/3, cz=(a.z+b.z+c.z)/3;
        const pc=projectPoint({x:cx,y:cy,z:cz});
        ctx.beginPath(); ctx.moveTo(rp.x, rp.y); ctx.lineTo(pc.x, pc.y); ctx.stroke();
      }
    }
    ctx.restore();
  }

  ctx.restore();

  function projectPoint(v){
    let x=(v.x-state.cx), y=(v.y-state.cy), z=(v.z-state.cz);
    let y1 = y*cosx - z*sinx, z1 = y*sinx + z*cosx;
    let x2 = x*cosy + z1*siny;
    const s = state.scale*state.zoom;
    return {x: x2*s + state.tx*CW/2, y: y1*s + state.ty*CH/2};
  }
}

/* ======================= DAT parser ======================= */
const datDrop   = document.getElementById('datDrop');
const datFile   = document.getElementById('datFile');
const datParse  = document.getElementById('datParse');
const datDL     = document.getElementById('datDownload');
const datClear  = document.getElementById('datClear');
const datLog    = document.getElementById('datLog');
const datStatus = document.getElementById('datStatus');
const datFname  = document.getElementById('datFname');
const datFsize  = document.getElementById('datFsize');
const datStats  = document.getElementById('datStats');
const datTableWrap = document.getElementById('datTableWrap');
const datPrev   = document.getElementById('datPreview');
const datPrevT  = datPrev.querySelector('tbody');
let datCurrentFile=null, datCsvUrl=null;

/* displacement field & time */
const datState = { order: [], dtimeByInc:new Map(), totalTimeByInc:new Map(), uByInc:new Map() };

function datHumanSize(bytes){ if(bytes<1024) return bytes+' B'; const u=['KB','MB','GB']; let i=-1; do{bytes/=1024;i++;}while(bytes>=1024&&i<u.length-1); return bytes.toFixed(2)+' '+u[i]; }
function datLogLine(s){ datLog.textContent += s + '\n'; datLog.scrollTop = datLog.scrollHeight; }
function datSetStatus(s){ datStatus.textContent = s || ''; }

function datAccept(f){
  datCurrentFile=f; datParse.disabled=false;
  datFname.style.display=datFsize.style.display='inline-block';
  datFname.textContent = `File: ${f.name}`;
  datFsize.textContent = `Size: ${datHumanSize(f.size)}`;
  datStats.style.display='none';
  datLog.textContent=''; datTableWrap.style.display='none'; datPrevT.innerHTML='';
  if(datCsvUrl){ URL.revokeObjectURL(datCsvUrl); datCsvUrl=null; }
  datDL.style.display='none';
  datSetStatus('Ready to parse');
  refreshDeformButtons();
}
datDrop.addEventListener('click', ()=>datFile.click());
datDrop.addEventListener('dragover', e=>{ e.preventDefault(); datDrop.classList.add('drag'); });
datDrop.addEventListener('dragleave', ()=> datDrop.classList.remove('drag'));
datDrop.addEventListener('drop', e=>{
  e.preventDefault(); datDrop.classList.remove('drag');
  const f=e.dataTransfer.files?.[0]; if(f) datAccept(f);
});
datFile.addEventListener('change', e=>{
  const f=e.target.files?.[0]; if(f) datAccept(f);
});

function parseDatToCsv(text){
  const lines = text.split(/\r?\n/); const n=lines.length;
  const incHeader=/^\s*INCREMENT\s+(\d+)\s+SUMMARY/i;
  const timeLine=/^\s*TIME INCREMENT COMPLETED\s+([-\d.E+]+)/i;
  const nodeOutputMarker='NODEOUTPUT';
  const headerRow=/NODE\s+.*U1\s+U2\s+U3/i;
  const numRow=/^\s*(\d+)\s+([-\d.E+]+)\s+([-\d.E+]+)\s+([-\d.E+]+)/;
  const isStop=s=>/^\s*(MAXIMUM|MINIMUM|INCREMENT\s+\d+\s+SUMMARY|N\s*O\s*D\s*E\s+O\s*U\s*T\s*P\s*U\s*T)/i.test(s);

  let i=0, totalRows=0, incCount=0;
  const out=['increment,time_increment,total_time,node,U1,U2,U3'];
  datState.order.length=0; datState.dtimeByInc=new Map(); datState.totalTimeByInc=new Map(); datState.uByInc.clear();

  let totalTime=0;
  while(i<n){
    const mInc = lines[i]?.match(incHeader);
    if(!mInc){ i++; continue; }
    const incIndex = parseInt(mInc[1],10); incCount++; i++;

    // find Î”t
    let dt = null, j=i;
    for(; j<n; j++){
      const t=lines[j]; const mt=t.match(timeLine);
      if(mt){ dt=parseFloat(mt[1]); break; }
      if(incHeader.test(t)) break;
    }
    i=j;
    if(dt==null) dt=0;
    totalTime += dt;
    datState.dtimeByInc.set(incIndex, dt);
    datState.totalTimeByInc.set(incIndex, totalTime);

    // find NODE OUTPUT
    for(; i<n; i++){
      const ns=lines[i].replace(/\s+/g,'').trim();
      if(ns==='NODEOUTPUT') break;
      if(incHeader.test(lines[i])) break;
    }
    if(i>=n || lines[i].replace(/\s+/g,'').trim()!=='NODEOUTPUT') continue;

    // header â†’ rows
    for(i++; i<n && !headerRow.test(lines[i]); i++){}
    if(i>=n) break;

    const map = new Map(); // node -> [u1,u2,u3]
    for(i++; i<n; i++){
      const s=lines[i];
      if(isStop(s)) break;
      const m=s.match(numRow);
      if(!m) continue;
      const node=parseInt(m[1],10), U1=parseFloat(m[2]), U2=parseFloat(m[3]), U3=parseFloat(m[4]);
      out.push(`${incIndex},${dt},${totalTime},${node},${U1},${U2},${U3}`);
      totalRows++;
      if(Number.isFinite(node)) map.set(node, [U1,U2,U3]);
    }
    datState.order.push(incIndex);
    datState.uByInc.set(incIndex, map);
  }
  return {csvText: out.join('\n'), totalRows, increments: incCount};
}

datParse.addEventListener('click', async ()=>{
  if(!datCurrentFile) return;
  datSetStatus('Readingâ€¦');
  const text = await datCurrentFile.text();
  datLogLine(`Loaded ${datCurrentFile.name} (${datHumanSize(datCurrentFile.size)}), ${text.length.toLocaleString()} chars`);
  datSetStatus('Parsingâ€¦');

  const t0=performance.now();
  const {csvText, totalRows, increments} = parseDatToCsv(text);
  const t1=performance.now();

  const blob=new Blob([csvText], {type:'text/csv;charset=utf-8'});
  datCsvUrl = URL.createObjectURL(blob);
  datDL.href = datCsvUrl;
  datDL.style.display='inline-block';
  datDL.download = (datCurrentFile.name.replace(/\.dat$/i,'') || 'output') + '_node_displacements_by_increment.csv';

  datStats.style.display='inline-block';
  datStats.textContent = `Rows: ${totalRows.toLocaleString()} Â· Increments: ${increments}`;
  datLogLine(`Parsed ${totalRows.toLocaleString()} rows across ${increments} increments in ${(t1-t0).toFixed(1)} ms`);
  datSetStatus('Done âœ“');

  // preview first ~200 lines
  datPrevT.innerHTML='';
  const rows = csvText.split('\n').slice(1, 201);
  for(const row of rows){
    if(!row.trim()) continue;
    const [inc,dt,tt,node,U1,U2,U3]=row.split(',');
    const tr=document.createElement('tr');
    for(const v of [inc,dt,tt,node,U1,U2,U3]){
      const td=document.createElement('td'); td.textContent=v; tr.appendChild(td);
    }
    datPrevT.appendChild(tr);
  }
  datTableWrap.style.display = rows.length ? 'block' : 'none';

  refreshDeformButtons();
  enableVolumeButtonsIfReady();
});

datClear.addEventListener('click', ()=>{
  datCurrentFile=null; datFile.value=''; datParse.disabled=true;
  if(datCsvUrl){ URL.revokeObjectURL(datCsvUrl); datCsvUrl=null; }
  datDL.style.display='none'; datTableWrap.style.display='none'; datPrevT.innerHTML='';
  datFname.style.display=datFsize.style.display=datStats.style.display='none';
  datLog.textContent=''; datSetStatus('');
  datState.order.length=0; datState.uByInc.clear(); datState.dtimeByInc.clear?.(); datState.totalTimeByInc.clear?.();
  refreshDeformButtons(); disableVolumeButtons();
});

/* enable/disable "Deform" based on DAT availability */
function refreshDeformButtons(){ const enabled = datState.order.length>0;
  document.querySelectorAll('.deformBtn').forEach(b=> b.disabled = !enabled); }

/* ======== Deformed surface overlay ======== */
let currentContext = null; // {part, surface, tris, nodeSet, mesh}

function startDeform(part, surface, tris, nodeSet){
  if(datState.order.length===0){ alert('Load and parse a DAT file first.'); return; }
  const mesh = buildMeshForViz(part, tris);
  currentContext = {part, surface, tris, nodeSet, mesh};
  showInViewer(mesh, part.name, surface.name, {showRef:true});

  deformControls.style.display='flex';
  incSlider.min = Math.min(...datState.order);
  incSlider.max = Math.max(...datState.order);
  incSlider.value = datState.order[0];
  scaleSlider.value = 1;
  scaleLabel.textContent = '1.00Ã—';
  updateOverlayFromControls();

  enableVolumeButtonsIfReady();
}
incSlider.addEventListener('input', ()=>{ updateOverlayFromControls(); });
scaleSlider.addEventListener('input', ()=>{
  scaleLabel.textContent = Number(scaleSlider.value).toFixed(2) + 'Ã—';
  updateOverlayFromControls();
});
function updateOverlayFromControls(){
  if(!currentContext) return;
  const inc = parseInt(incSlider.value,10);
  incLabel.textContent = inc;
  const dt = datState.dtimeByInc.get(inc) ?? '';
  const tt = datState.totalTimeByInc.get(inc) ?? '';
  timeLabel.textContent = `Î”t=${dt} â€¢ t=${tt}`;

  const scale = parseFloat(scaleSlider.value);
  const uMap = datState.uByInc.get(inc);
  if(!uMap){ state.overlayVerts=null; state.overlayFaces=null; draw(); return; }

  const verts = currentContext.mesh.verts.map(v=>{
    const u = uMap.get(v.id);
    if(u){ return {x: v.x + u[0]*scale, y: v.y + u[1]*scale, z: v.z + u[2]*scale, id:v.id}; }
    return {x:v.x, y:v.y, z:v.z, id:v.id};
  });

  state.overlayVerts = verts;
  state.overlayFaces = currentContext.mesh.faces;
  draw();
}

/* ================== Reference point & volume ================== */
setRef.addEventListener('click', ()=>{
  if(!currentContext){ alert('Select a surface first.'); return; }
  const x=parseFloat(refX.value), y=parseFloat(refY.value), z=parseFloat(refZ.value);
  if(![x,y,z].every(Number.isFinite)){ alert('Enter numeric x, y, z.'); return; }
  state.refPoint = {x,y,z}; state.showRef = true; draw();
  togglePreview.disabled=false;
  enableVolumeButtonsIfReady();
});
togglePreview.addEventListener('click', ()=>{
  if(!state.refPoint){ alert('Set a reference point first.'); return; }
  state.showPreview = !state.showPreview;
  togglePreview.textContent = state.showPreview ? 'Hide preview' : 'Check volume';
  draw();
});

function volumeFrom(ref, tris, getPos, signed=true){
  let sum = 0;
  for (const t of tris){
    const a = getPos(t[0]), b = getPos(t[1]), c = getPos(t[2]);
    const ax=a[0]-ref.x, ay=a[1]-ref.y, az=a[2]-ref.z;
    const bx=b[0]-ref.x, by=b[1]-ref.y, bz=b[2]-ref.z;
    const cx=c[0]-ref.x, cy=c[1]-ref.y, cz=c[2]-ref.z;
    const v = (ax*(by*cz - bz*cy) - ay*(bx*cz - bz*cx) + az*(bx*cy - by*cx)) / 6; // signed triple product
    sum += signed ? v : Math.abs(v);
  }
  return sum;
}

function populateAmpSelect(){
  const sel=ampSelect; const prev=sel.value;
  sel.innerHTML='<option value="">(none)</option>';
  lastAmplitudes.forEach((a,i)=>{
    const opt=document.createElement('option');
    opt.value=String(i); opt.textContent=a.name; sel.appendChild(opt);
  });
  if(lastAmplitudes.length) sel.value=prev || '';
}

runSeries.addEventListener('click', ()=>{
  if(!currentContext){ alert('Select a surface first.'); return; }
  if(!state.refPoint){ alert('Set a reference point first.'); return; }
  if(datState.order.length===0){ alert('Load and parse a DAT file first.'); return; }

  const signed = document.getElementById('signedVol')?.checked ?? true;
  const {tris, mesh} = currentContext;

  // base nodal positions
  const base = new Map(); for (const v of mesh.verts){ base.set(v.id,[v.x,v.y,v.z]); }

  // interpolate amplitude at total time (if any)
  let amp=null;
  const idx = ampSelect.value==='' ? -1 : parseInt(ampSelect.value,10);
  if(idx>=0) amp = lastAmplitudes[idx];
  const interp = amp ? (t=>{
    const p=amp.pairs; if(!p.length) return '';
    if(t<=p[0][0]) return p[0][1];
    if(t>=p[p.length-1][0]) return p[p.length-1][1];
    let lo=0, hi=p.length-1;
    for(let k=1;k<p.length;k++){ if(t<p[k][0]){ hi=k; lo=k-1; break; } }
    const t0=p[lo][0], v0=p[lo][1], t1=p[hi][0], v1=p[hi][1];
    const a=(t-t0)/(t1-t0);
    return v0 + a*(v1-v0);
  }) : null;

  const rows=[]; const csv=['increment,dt,total_t,volume,amplitude'];

  // increment 0 / original
  const v0 = volumeFrom(state.refPoint, tris, id=>base.get(id), signed);
  rows.push({inc:0, dt:0, tt:0, vol:v0, amp:(interp?interp(0):'')});
  csv.push(`0,0,0,${v0},${interp?interp(0):''}`);

  for (const inc of datState.order){
    const map = datState.uByInc.get(inc) || new Map();
    const getPos = id=>{
      const b = base.get(id); const u = map.get(id);
      return u ? [b[0]+u[0], b[1]+u[1], b[2]+u[2]] : b;
    };
    const vol = volumeFrom(state.refPoint, tris, getPos, signed);
    const dt = datState.dtimeByInc.get(inc) ?? '';
    const tt = datState.totalTimeByInc.get(inc) ?? '';
    const av = interp ? interp(tt) : '';
    rows.push({inc, dt, tt, vol, amp: av});
    csv.push(`${inc},${dt},${tt},${vol},${av}`);
  }

  // table + csv (unchanged)
  volTableBody.innerHTML='';
  for(const r of rows){
    const tr=document.createElement('tr');
    [r.inc, r.dt, r.tt, r.vol, r.amp].forEach(v=>{
      const td=document.createElement('td'); td.textContent=v; tr.appendChild(td);
    });
    volTableBody.appendChild(tr);
  }
  volTableWrap.style.display='block';
  const blob=new Blob([csv.join('\n')], {type:'text/csv;charset=utf-8'});
  const url=URL.createObjectURL(blob); volCsv.href=url; volCsv.style.display='inline-block';
});


function enableVolumeButtonsIfReady(){
  const ok = !!currentContext; // surface selected
  runSeries.disabled = !ok;
}
function disableVolumeButtons(){
  runSeries.disabled = true; volCsv.style.display='none'; volTableWrap.style.display='none';
}
</script>
</body>
</html>
