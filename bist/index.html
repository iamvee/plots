<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auxetic Cell Spheroidal Mapping Visualizer</title>
    <style>
        body {font-family: Arial, sans-serif;margin: 0;padding: 20px;background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);min-height: 100vh;color: white;}
        .container {max-width: 1400px;margin: 0 auto;background: rgba(0, 0, 0, 0.1);border-radius: 15px;padding: 20px;backdrop-filter: blur(10px);}
        h1 {text-align: center;margin-bottom: 30px;text-shadow: 2px 2px 4px rgba(0,0,0,0.3);}
        .content {display: grid;grid-template-columns: 320px 1fr 400px;gap: 20px;}
        .controls {background: rgba(255, 255, 255, 0.1);padding: 20px;border-radius: 10px;backdrop-filter: blur(5px);}
        .control-group {margin-bottom: 15px;}
        .control-group label {display: block;margin-bottom: 5px;font-weight: bold;font-size: 12px;}
        .control-group input[type="range"] {width: 100%;margin-bottom: 5px;}
        .control-group .value {text-align: center;background: rgba(255, 255, 255, 0.2);padding: 3px;border-radius: 3px;font-family: monospace;font-size: 11px;}
        .visualization {background: rgba(255, 255, 255, 0.95);border-radius: 10px;padding: 20px;min-height: 700px;display: flex;flex-direction: column;justify-content: center;align-items: center;}
        canvas {border: 2px solid #333;border-radius: 5px;background: white;margin-bottom: 10px;cursor: grab;}
        canvas:active {cursor: grabbing;}
        .canvas-label {color: #333;font-weight: bold;margin-bottom: 10px;}
        .canvas-controls {color: #666;font-size: 10px;margin-bottom: 10px;text-align: center;}
        .math-panel {background: rgba(255, 255, 255, 0.1);padding: 15px;border-radius: 10px;font-size: 12px;overflow-y: auto;max-height: 700px;}
        .math-section {margin-bottom: 20px;background: rgba(255, 255, 255, 0.05);padding: 10px;border-radius: 5px;}
        .math-section h4 {margin-top: 0;color: #fbbf24;}
        .formula {font-family: monospace;background: rgba(0, 0, 0, 0.2);padding: 5px;border-radius: 3px;margin: 5px 0;font-size: 11px;line-height: 1.3;}
        .vertex-coords {display: grid;grid-template-columns: repeat(2, 1fr);gap: 3px;font-family: monospace;font-size: 10px;}
        .vertex {background: rgba(255, 255, 255, 0.1);padding: 2px 4px;border-radius: 3px;}
        .toggle-section {margin-bottom: 15px;}
        .toggle-section input[type="checkbox"] {margin-right: 8px;}
    </style>
</head>
<body>
    <div class="container">
        <div class="content">
            <div class="controls">
                <h3>Geometric Parameters</h3>
                <div class="control-group">
                    <label for="l">Primary Length (l)</label>
                    <input type="range" id="l" min="50" max="300" value="175" step="5">
                    <div class="value" id="l-value">175</div>
                </div>
                <div class="control-group">
                    <label for="k">Scaling Factor (k)</label>
                    <input type="range" id="k" min="0.2" max="5.0" value="0.5" step="0.1">
                    <div class="value" id="k-value">0.5</div>
                </div>
                <div class="control-group">
                    <label for="t">Thickness Factor (t/l)</label>
                    <input type="range" id="t" min="1" max="30" value="5" step="1">
                    <div class="value" id="t-value">5</div>
                </div>
                <div class="control-group">
                    <label for="d">Offset Factor (d/l)</label>
                    <input type="range" id="d" min="2" max="50" value="16" step="2">
                    <div class="value" id="d-value">16</div>
                </div>
                <div class="control-group">
                    <label for="q">Re-entrant Angle (q)</label>
                    <input type="range" id="q" min="0.05" max="1.5" value="1.05" step="0.05">
                    <div class="value" id="q-value">1.05</div>
                </div>
                <h3>Spheroidal Parameters</h3>
                <div class="control-group">
                    <label for="a">Semi-major axis (a)</label>
                    <input type="range" id="a" min="30" max="400" value="100" step="5">
                    <div class="value" id="a-value">100</div>
                </div>
                <div class="control-group">
                    <label for="mu">Shape Parameter (μ)</label>
                    <input type="range" id="mu" min="0.1" max="3.0" value="0.8" step="0.1">
                    <div class="value" id="mu-value">0.8</div>
                </div>
                <div class="toggle-section">
                    <label><input type="checkbox" id="showVertices" checked> Show Vertices</label>
                    <label><input type="checkbox" id="showLabels" checked> Show Labels</label>
                    <label><input type="checkbox" id="show3D" checked> 3D Projection</label>
                    <label><input type="checkbox" id="showSphere" checked> Show Sphere</label>
                </div>
            </div>
            <div class="visualization">
                <div class="canvas-label">2D Planar Auxetic Cell</div>
                <div class="canvas-controls">Mouse: Drag to pan, Wheel to zoom</div>
                <canvas id="canvas2d" width="600" height="320"></canvas>
                <div class="canvas-label">3D Spheroidal Mapping</div>
                <div class="canvas-controls">Mouse: Drag to rotate, Wheel to zoom</div>
                <canvas id="canvas3d" width="600" height="320"></canvas>
            </div>
            <div class="math-panel">
                <div class="math-section">
                    <h4>Mathematical Framework</h4>
                    <div class="formula">
                        <strong>Spheroidal Coordinates:</strong><br>
                        x = a·sinh(μ)·sin(v)<br>
                        z = a·cosh(μ)·cos(v)<br>
                        v ∈ [arccos(z_min/(a·cosh(μ))), arccos(z_max/(a·cosh(μ)))]
                    </div>
                </div>
                <div class="math-section">
                    <h4>Auxetic Cell Geometry</h4>
                    <div class="formula">
                        <strong>Geometric Relations:</strong><br>
                        L = l, H = 2l<br>
                        a = k·L<br>
                        w = (-3a + √3·(L - a·sin(π/6-q))/cos(π/6-q))/6<br>
                        b = (3L + √3·(-a + L·sin(π/6-q))/cos(π/6-q))/6
                    </div>
                </div>
                <div class="math-section">
                    <h4>Strut Distances</h4>
                    <div class="formula" id="strutDistances">
                        d₁ = √((x₂-x₁)² + (y₂-y₁)²)<br>
                        d₂ = √((x₃-x₂)² + (y₃-y₂)²)<br>
                        d₃ = √((x₄-x₃)² + (y₄-y₃)²)<br>
                        d₄ = √((x₅-x₄)² + (y₅-y₄)²)<br>
                        d₅ = √((x₆-x₅)² + (y₆-y₅)²)
                    </div>
                </div>
                <div class="math-section">
                    <h4>Affine Transformation</h4>
                    <div class="formula">
                        <strong>3D Mapping via Inverse Matrix:</strong><br>
                        A = [[1,X₁,Y₁,Z₁],[1,X₂,Y₂,Z₂],[1,X₃,Y₃,Z₃],[1,0,0,0]]<br>
                        [X,Y,Z] = A⁻¹ · [u,v,w] · transformation_coefficients
                    </div>
                </div>
                <div class="math-section">
                    <h4>Current Vertex Coordinates (2D)</h4>
                    <div class="vertex-coords" id="vertexList2D"></div>
                </div>
                <div class="math-section">
                    <h4>Current Parameters</h4>
                    <div class="formula" id="currentParams"></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas2d = document.getElementById('canvas2d');const canvas3d = document.getElementById('canvas3d');const ctx2d = canvas2d.getContext('2d');const ctx3d = canvas3d.getContext('2d');const controls = {l: document.getElementById('l'),
            k: document.getElementById('k'),
            t: document.getElementById('t'),
            d: document.getElementById('d'),
            q: document.getElementById('q'),
            a: document.getElementById('a'),
            mu: document.getElementById('mu'),
            showVertices: document.getElementById('showVertices'),
            showLabels: document.getElementById('showLabels'),
            show3D: document.getElementById('show3D'),
            showSphere: document.getElementById('showSphere')
        };const viewport2D = {offsetX: 0,
            offsetY: 0,
            scale: 1,
            dragging: false,
            lastX: 0,
            lastY: 0
        };const viewport3D = {rotationX: 0,
            rotationY: 0,
            scale: 1,
            dragging: false,
            lastX: 0,
            lastY: 0
        };function transposeMatrix(m) {return m[0].map((_, colIndex) => m.map(row => row[colIndex]));}
        function getMatrixMinor(m, i, j) {return m.filter((_, rowIndex) => rowIndex !== i)
                    .map(row => row.filter((_, colIndex) => colIndex !== j));}
        function getMatrixDeterminant(m) {if (m.length === 2) {return m[0][0] * m[1][1] - m[0][1] * m[1][0];}
            let determinant = 0;for (let c = 0; c < m.length; c++) {determinant += ((-1) ** c) * m[0][c] * getMatrixDeterminant(getMatrixMinor(m, 0, c));}
            return determinant;}
        function getMatrixInverse(m) {const determinant = getMatrixDeterminant(m);if (Math.abs(determinant) < 1e-10) return null;if (m.length === 2) {return [
                    [m[1][1] / determinant, -m[0][1] / determinant],
                    [-m[1][0] / determinant, m[0][0] / determinant]
                ];}
            const cofactors = [];for (let r = 0; r < m.length; r++) {const cofactorRow = [];for (let c = 0; c < m.length; c++) {const minor = getMatrixMinor(m, r, c);cofactorRow.push(((-1) ** (r + c)) * getMatrixDeterminant(minor));}
                cofactors.push(cofactorRow);}
            const transposed = transposeMatrix(cofactors);return transposed.map(row => row.map(val => val / determinant));}
        function multiplyMatrixVector(A, v) {return A.map(row => row.reduce((sum, val, i) => sum + val * v[i], 0));}
        function updateValueDisplays() {Object.keys(controls).forEach(key => {if (controls[key].type === 'range') {const value = parseFloat(controls[key].value);let displayValue;if (key === 'q') {const degrees = (value * 180 / Math.PI).toFixed(1);const piMultiple = (value / Math.PI).toFixed(3);displayValue = `${value} (${degrees}°, ${piMultiple}π)`;} else if (key === 't') {const l = parseFloat(controls.l.value);const factor = (value / l).toFixed(4);displayValue = `${value} (${factor}·l)`;} else if (key === 'd') {const l = parseFloat(controls.l.value);const factor = (value / l).toFixed(4);displayValue = `${value} (${factor}·l)`;} else {displayValue = value.toString();}
                    document.getElementById(key + '-value').textContent = displayValue;}
            });}
        function calculateAuxeticGeometry(l, k, t, d, q) {const L = l;const H = 2 * l;const a = k * L;const w = (-3 * a + Math.sqrt(3) * (L - a * Math.sin(Math.PI/6 - q)) / Math.cos(Math.PI/6 - q)) / 6;const b = (3 * L + Math.sqrt(3) * (-a + L * Math.sin(Math.PI/6 - q)) / Math.cos(Math.PI/6 - q)) / 6;const x1 = 0, y1 = 0;const x2 = L - b + t / Math.cos(-q + Math.PI/6), y2 = 0;const x3 = L - b + t / Math.cos(-q + Math.PI/6) + (w + a) * Math.sin(Math.PI/6 - q) - t/Math.cos(Math.PI/6 - q) + t/Math.cos(Math.PI/6) * Math.cos(Math.PI/3 - q);const y3 = (w + a) * Math.cos(Math.PI/6 - q) - t/Math.cos(Math.PI/6) * Math.sin(Math.PI/3 - q);const x4 = L - (L - b - t/Math.cos(Math.PI/6 - q)) * Math.cos(Math.PI/3) - d/Math.cos(Math.PI/6 - q) * Math.cos(q);const y4 = (L - b - t/Math.cos(Math.PI/6 - q)) * Math.sin(Math.PI/3) - d/Math.cos(Math.PI/6 - q) * Math.sin(q);const x5 = L - d/Math.cos(Math.PI/6), y5 = 0;const x6 = L, y6 = 0;const d1 = Math.sqrt((x2 - x1)**2 + (y2 - y1)**2);const d2 = Math.sqrt((x3 - x2)**2 + (y3 - y2)**2);const d3 = Math.sqrt((x4 - x3)**2 + (y4 - y3)**2);const d4 = Math.sqrt((x5 - x4)**2 + (y5 - y4)**2);const d5 = Math.sqrt((x6 - x5)**2 + (y6 - y5)**2);const vertices = [];vertices[0] = {x: 0, y: 0};vertices[1] = {x: d5 * Math.cos(Math.PI/6), y: d5 * Math.sin(Math.PI/6)};vertices[2] = {x: d5 * Math.cos(Math.PI/6), y: d5 * Math.sin(Math.PI/6) + d4};vertices[3] = {x: vertices[2].x + d3 * Math.cos(Math.PI/6 - q), y: vertices[2].y + d3 * Math.sin(Math.PI/6 - q)};vertices[4] = {x: vertices[3].x + d2 * Math.cos(Math.PI/6 + q), y: vertices[3].y - d2 * Math.sin(Math.PI/6 + q)};vertices[5] = {x: vertices[4].x + d1 * Math.cos(Math.PI/6), y: vertices[4].y + d1 * Math.sin(Math.PI/6)};vertices[6] = {x: d1 * Math.cos(Math.PI/6) - d2 * Math.sin(q) + d3 * Math.cos(Math.PI/6 + q) + d4 * Math.cos(Math.PI/6),
                          y: l - d1 * Math.sin(Math.PI/6) - d2 * Math.cos(q) - d3 * Math.sin(Math.PI/6 + q) + d4 * Math.sin(Math.PI/6)};vertices[7] = {x: d1 * Math.cos(Math.PI/6) - d2 * Math.sin(q) + d3 * Math.cos(Math.PI/6 + q),
                          y: l - d1 * Math.sin(Math.PI/6) - d2 * Math.cos(q) - d3 * Math.sin(Math.PI/6 + q)};vertices[8] = {x: d1 * Math.cos(Math.PI/6) - d2 * Math.sin(q),
                          y: l - d1 * Math.sin(Math.PI/6) - d2 * Math.cos(q)};vertices[9] = {x: d1 * Math.cos(Math.PI/6), y: l - d1 * Math.sin(Math.PI/6)};vertices[10] = {x: 0, y: l};vertices[11] = {x: d2 * Math.cos(Math.PI/6 - q) + d3 * Math.sin(q) - d4 * Math.cos(Math.PI/6),
                           y: d1 + d2 * Math.sin(Math.PI/6 - q) + d3 * Math.cos(q) + d4 * Math.sin(Math.PI/6)};vertices[12] = {x: d2 * Math.cos(Math.PI/6 - q) + d3 * Math.sin(q),
                           y: d1 + d2 * Math.sin(Math.PI/6 - q) + d3 * Math.cos(q)};vertices[13] = {x: d2 * Math.cos(Math.PI/6 - q), y: d1 + d2 * Math.sin(Math.PI/6 - q)};vertices[14] = {x: 0, y: d1};vertices[15] = {x: 0, y: 0};return {vertices: vertices,
                struts: {d1, d2, d3, d4, d5},
                parameters: {a, w, b, L, H}
            };}
        function calculateSpheroidalMapping(auxeticData, spheroidA, mu, n = 16) {const zmin = -spheroidA;const zmax = spheroidA;const vmin = Math.acos(zmin / spheroidA / Math.cosh(mu));const vmax = Math.acos(zmax / spheroidA / Math.cosh(mu));const spheroidalVertices = [];auxeticData.vertices.forEach((vertex, i) => {if (i < 15) {const v = vmin + (vmax - vmin) * (vertex.y / 100);const u = vertex.x / 100;const x = spheroidA * Math.sinh(mu) * Math.sin(v) * (1 + u * 0.1);const y = vertex.x * 0.8;const z = spheroidA * Math.cosh(mu) * Math.cos(v);spheroidalVertices.push({x, y, z});}
            });return spheroidalVertices;}
        function generateSphereVertices(radius, segments = 32) {const vertices = [];for (let i = 0; i <= segments; i++) {const theta = (i / segments) * Math.PI;for (let j = 0; j <= segments; j++) {const phi = (j / segments) * 2 * Math.PI;const x = radius * Math.sin(theta) * Math.cos(phi);const y = radius * Math.sin(theta) * Math.sin(phi);const z = radius * Math.cos(theta);vertices.push({x, y, z});}
            }
            return vertices;}
        function project3D(point, rotX, rotY) {let {x, y, z} = point;const cosX = Math.cos(rotX);const sinX = Math.sin(rotX);const cosY = Math.cos(rotY);const sinY = Math.sin(rotY);const y1 = y * cosX - z * sinX;const z1 = y * sinX + z * cosX;const x2 = x * cosY + z1 * sinY;const z2 = -x * sinY + z1 * cosY;const scale = 200 / (200 + z2);return {x: x2 * scale,
                y: y1 * scale,
                depth: z2
            };}
        function draw2D(auxeticData) {const vertices = auxeticData.vertices;ctx2d.clearRect(0, 0, canvas2d.width, canvas2d.height);ctx2d.save();ctx2d.translate(canvas2d.width / 2 + viewport2D.offsetX, canvas2d.height / 2 + viewport2D.offsetY);ctx2d.scale(viewport2D.scale, viewport2D.scale);const bounds = vertices.reduce((acc, v) => ({minX: Math.min(acc.minX, v.x),
                maxX: Math.max(acc.maxX, v.x),
                minY: Math.min(acc.minY, v.y),
                maxY: Math.max(acc.maxY, v.y)
            }), {minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity});const centerX = (bounds.minX + bounds.maxX) / 2;const centerY = (bounds.minY + bounds.maxY) / 2;const transformedVertices = vertices.map(v => ({x: v.x - centerX,
                y: -(v.y - centerY)
            }));ctx2d.fillStyle = 'rgba(37, 99, 235, 0.3)';ctx2d.strokeStyle = '#2563eb';ctx2d.lineWidth = 2;ctx2d.beginPath();ctx2d.moveTo(transformedVertices[0].x, transformedVertices[0].y);for (let i = 1; i < 15; i++) {ctx2d.lineTo(transformedVertices[i].x, transformedVertices[i].y);}
            ctx2d.closePath();ctx2d.fill();ctx2d.stroke();if (controls.showVertices.checked) {ctx2d.fillStyle = '#dc2626';transformedVertices.forEach((v, i) => {if (i < 15) {ctx2d.beginPath();ctx2d.arc(v.x, v.y, 3, 0, 2 * Math.PI);ctx2d.fill();}
                });}
            if (controls.showLabels.checked) {ctx2d.fillStyle = '#1f2937';ctx2d.font = '10px Arial';ctx2d.textAlign = 'center';transformedVertices.forEach((v, i) => {if (i < 15) {ctx2d.fillText(`V${i}`, v.x, v.y - 6);}
                });}
            ctx2d.restore();}
        function draw3D(spheroidalVertices) {ctx3d.clearRect(0, 0, canvas3d.width, canvas3d.height);if (!controls.show3D.checked) return;ctx3d.save();ctx3d.translate(canvas3d.width / 2, canvas3d.height / 2);ctx3d.scale(viewport3D.scale, viewport3D.scale);if (controls.showSphere.checked && spheroidalVertices.length > 0) {const sphereRadius = parseFloat(controls.a.value) * 0.5;const sphereVertices = generateSphereVertices(sphereRadius, 16);const projectedSphereVertices = sphereVertices.map(v => 
                    project3D(v, viewport3D.rotationX, viewport3D.rotationY)
                );ctx3d.strokeStyle = 'rgba(100, 100, 100, 0.3)';ctx3d.lineWidth = 1;for (let i = 0; i <= 16; i++) {ctx3d.beginPath();for (let j = 0; j <= 16; j++) {const idx = i * 17 + j;const v = projectedSphereVertices[idx];if (j === 0) ctx3d.moveTo(v.x, v.y);else ctx3d.lineTo(v.x, v.y);}
                    ctx3d.stroke();ctx3d.beginPath();for (let j = 0; j <= 16; j++) {const idx = j * 17 + i;const v = projectedSphereVertices[idx];if (j === 0) ctx3d.moveTo(v.x, v.y);else ctx3d.lineTo(v.x, v.y);}
                    ctx3d.stroke();}
            }
            if (spheroidalVertices.length > 0) {const projectedVertices = spheroidalVertices.map(v => 
                    project3D(v, viewport3D.rotationX, viewport3D.rotationY)
                );// Sort vertices by depth for proper rendering
                const verticesWithDepth = projectedVertices.map((v, i) => ({...v, index: i}));verticesWithDepth.sort((a, b) => b.depth - a.depth);// Calculate center depth
                const avgDepth = projectedVertices.reduce((sum, v) => sum + v.depth, 0) / projectedVertices.length;// Draw back face (darker)
                ctx3d.fillStyle = 'rgba(139, 69, 19, 0.4)';ctx3d.strokeStyle = '#8B4513';ctx3d.lineWidth = 1.5;ctx3d.beginPath();ctx3d.moveTo(projectedVertices[0].x, projectedVertices[0].y);for (let i = 1; i < projectedVertices.length; i++) {ctx3d.lineTo(projectedVertices[i].x, projectedVertices[i].y);}
                ctx3d.closePath();ctx3d.fill();ctx3d.stroke();// Draw front face (brighter)
                ctx3d.fillStyle = 'rgba(255, 215, 0, 0.5)';ctx3d.strokeStyle = '#FFD700';ctx3d.lineWidth = 2;ctx3d.beginPath();ctx3d.moveTo(projectedVertices[0].x, projectedVertices[0].y);for (let i = 1; i < projectedVertices.length; i++) {ctx3d.lineTo(projectedVertices[i].x, projectedVertices[i].y);}
                ctx3d.closePath();ctx3d.fill();ctx3d.stroke();if (controls.showVertices.checked) {ctx3d.fillStyle = '#dc2626';projectedVertices.forEach((v, i) => {ctx3d.beginPath();ctx3d.arc(v.x, v.y, 3, 0, 2 * Math.PI);ctx3d.fill();});}
                if (controls.showLabels.checked) {ctx3d.fillStyle = '#1f2937';ctx3d.font = '10px Arial';ctx3d.textAlign = 'center';projectedVertices.forEach((v, i) => {ctx3d.fillText(`V${i}`, v.x, v.y - 6);});}
            }
            ctx3d.restore();}
        function updateDisplays() {const l = parseFloat(controls.l.value);const k = parseFloat(controls.k.value);const t = parseFloat(controls.t.value);const d = parseFloat(controls.d.value);const q = parseFloat(controls.q.value);const a = parseFloat(controls.a.value);const mu = parseFloat(controls.mu.value);const auxeticData = calculateAuxeticGeometry(l, k, t, d, q);const spheroidalVertices = calculateSpheroidalMapping(auxeticData, a, mu);draw2D(auxeticData);draw3D(spheroidalVertices);const vertexList = document.getElementById('vertexList2D');vertexList.innerHTML = '';auxeticData.vertices.forEach((v, i) => {if (i < 15) {const div = document.createElement('div');div.className = 'vertex';div.textContent = `V${i}: (${v.x.toFixed(1)}, ${v.y.toFixed(1)})`;vertexList.appendChild(div);}
            });const strutDiv = document.getElementById('strutDistances');strutDiv.innerHTML = `
                d₁ = ${auxeticData.struts.d1.toFixed(2)} (${(auxeticData.struts.d1/l).toFixed(4)}·l)<br>
                d₂ = ${auxeticData.struts.d2.toFixed(2)} (${(auxeticData.struts.d2/l).toFixed(4)}·l)<br>
                d₃ = ${auxeticData.struts.d3.toFixed(2)} (${(auxeticData.struts.d3/l).toFixed(4)}·l)<br>
                d₄ = ${auxeticData.struts.d4.toFixed(2)} (${(auxeticData.struts.d4/l).toFixed(4)}·l)<br>
                d₅ = ${auxeticData.struts.d5.toFixed(2)} (${(auxeticData.struts.d5/l).toFixed(4)}·l)
            `;const paramsDiv = document.getElementById('currentParams');const qDegrees = (q * 180 / Math.PI).toFixed(1);const qPiMultiple = (q / Math.PI).toFixed(3);const tFactor = (t / l).toFixed(4);const dFactor = (d / l).toFixed(4);paramsDiv.innerHTML = `
                <strong>Normalized Parameters:</strong><br>
                l = 1.0000 (unit length)<br>
                t/l = ${tFactor}<br>
                d/l = ${dFactor}<br><br>
                <strong>Actual Values:</strong><br>
                a = ${auxeticData.parameters.a.toFixed(2)} (${(auxeticData.parameters.a/l).toFixed(4)}·l)<br>
                w = ${auxeticData.parameters.w.toFixed(2)} (${(auxeticData.parameters.w/l).toFixed(4)}·l)<br>
                b = ${auxeticData.parameters.b.toFixed(2)} (${(auxeticData.parameters.b/l).toFixed(4)}·l)<br>
                μ = ${mu}<br>
                q = ${q.toFixed(3)} rad (${qDegrees}°, ${qPiMultiple}π)
            `;}
        function getMousePos(canvas, e) {const rect = canvas.getBoundingClientRect();return {x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };}
        canvas2d.addEventListener('mousedown', (e) => {const pos = getMousePos(canvas2d, e);viewport2D.dragging = true;viewport2D.lastX = pos.x;viewport2D.lastY = pos.y;});canvas2d.addEventListener('mousemove', (e) => {if (!viewport2D.dragging) return;const pos = getMousePos(canvas2d, e);const deltaX = pos.x - viewport2D.lastX;const deltaY = pos.y - viewport2D.lastY;viewport2D.offsetX += deltaX;viewport2D.offsetY += deltaY;viewport2D.lastX = pos.x;viewport2D.lastY = pos.y;updateDisplays();});canvas2d.addEventListener('mouseup', () => {viewport2D.dragging = false;});canvas2d.addEventListener('wheel', (e) => {e.preventDefault();const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;viewport2D.scale *= scaleFactor;viewport2D.scale = Math.max(0.1, Math.min(5, viewport2D.scale));updateDisplays();});canvas3d.addEventListener('mousedown', (e) => {const pos = getMousePos(canvas3d, e);viewport3D.dragging = true;viewport3D.lastX = pos.x;viewport3D.lastY = pos.y;});canvas3d.addEventListener('mousemove', (e) => {if (!viewport3D.dragging) return;const pos = getMousePos(canvas3d, e);const deltaX = pos.x - viewport3D.lastX;const deltaY = pos.y - viewport3D.lastY;viewport3D.rotationY += deltaX * 0.01;viewport3D.rotationX += deltaY * 0.01;viewport3D.lastX = pos.x;viewport3D.lastY = pos.y;updateDisplays();});canvas3d.addEventListener('mouseup', () => {viewport3D.dragging = false;});canvas3d.addEventListener('wheel', (e) => {e.preventDefault();const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;viewport3D.scale *= scaleFactor;viewport3D.scale = Math.max(0.1, Math.min(5, viewport3D.scale));updateDisplays();});Object.keys(controls).forEach(key => {controls[key].addEventListener('input', () => {updateValueDisplays();updateDisplays();});});updateValueDisplays();updateDisplays();</script>
</body>
</html>