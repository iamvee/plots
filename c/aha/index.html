
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate AHA 17-Segment Bull's Eye Plot Generator</title>
    <!-- We'll use this for PDF exporting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 20px;
            min-height: 100vh;
        }

        .sidebar {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            height: fit-content;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        .main-content {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
        }

        .section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e2e8f0;
        }
        .section:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        .section h3 {
            margin-bottom: 15px;
            color: #4a5568;
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
        }
        
        .section h3::before {
            content: attr(data-icon);
            margin-right: 8px;
            font-size: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            font-size: 14px;
            color: #2d3748;
        }

        input, select, textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.2s ease;
            background: #f7fafc;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.2);
            background: white;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-container input[type="range"] {
            flex: 1;
        }

        .slider-value {
            min-width: 50px;
            text-align: center;
            background: #edf2f7;
            border: 1px solid #e2e8f0;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        button, .file-upload-label {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            text-align: center;
        }

        button:hover, .file-upload-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(66, 153, 225, 0.3);
        }

        .btn-secondary { background: linear-gradient(135deg, #48bb78 0%, #38a169 100%); }
        .btn-secondary:hover { box-shadow: 0 4px 15px rgba(72, 187, 120, 0.3); }
        .btn-danger { background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%); }
        .btn-danger:hover { box-shadow: 0 4px 15px rgba(245, 101, 101, 0.3); }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .input-tabs {
            display: flex;
            margin-bottom: 15px;
            background: #edf2f7;
            border-radius: 8px;
            padding: 4px;
        }

        .tab-button {
            flex: 1;
            padding: 8px 10px;
            background: none;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
            font-weight: 500;
            color: #4a5568;
        }

        .tab-button.active {
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            color: #2d3748;
        }

        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .data-table-container {
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .data-table th, .data-table td {
            border: 1px solid #e2e8f0;
            padding: 8px;
            text-align: center;
        }
        .data-table th { background: #f7fafc; font-weight: 600; position: sticky; top: 0; }
        .data-table input { width: 100%; padding: 4px; font-size: 12px; margin: 0; text-align: center; }
        .data-table td:first-child { font-weight: 600; }

        .plot-container {
            flex: 1;
            position: relative;
            background: #f7fafc;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 600px;
        }

        .plot-placeholder { text-align: center; color: #a0aec0; font-size: 18px; }
        #plotCanvas { max-width: 100%; max-height: 100%; border-radius: 10px; }

        .legend {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            cursor: move;
            z-index: 100;
            user-select: none;
        }
        
        #tooltip {
            position: absolute;
            display: none;
            background: rgba(45, 55, 72, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            z-index: 200;
            pointer-events: none; /* Important so it doesn't block mouse events on the canvas */
        }
        
        .json-input { min-height: 120px; font-family: 'Monaco', 'Menlo', monospace; font-size: 12px; }
        .message { font-size: 12px; margin-top: 5px; display: none; }
        .error-message { color: #e53e3e; }
        .success-message { color: #38a169; }

        .flex-group { display: flex; gap: 10px; }
        .flex-group > * { flex: 1; }
        
        input[type="file"] { display: none; }

        @media (max-width: 1200px) {
            .container { grid-template-columns: 1fr; gap: 15px; }
            .sidebar { max-height: none; }
        }
    </style>
</head>
<body>
    <div id="tooltip"></div>
    <div class="container">
        <div class="sidebar">
            <!-- Data Input Section -->
            <div class="section">
                <h3 data-icon="📊">Data Input</h3>
                <div class="input-tabs">
                    <button class="tab-button active" onclick="switchTab('json')">JSON</button>
                    <button class="tab-button" onclick="switchTab('csv')">CSV/File</button>
                    <button class="tab-button" onclick="switchTab('manual')">Manual</button>
                </div>
                
                <div id="json-tab" class="tab-content active">
                    <div class="form-group">
                        <label for="jsonInput">JSON Data:</label>
                        <textarea id="jsonInput" class="json-input" placeholder='{"1": {"value": 0.8, "std": 0.1}, ...}'></textarea>
                        <div id="jsonMessage" class="message"></div>
                    </div>
                    <button onclick="loadJsonData()">Load JSON Data</button>
                </div>

                <div id="csv-tab" class="tab-content">
                    <div class="form-group">
                        <label for="csvFileInput" class="file-upload-label">Select .csv or .txt file</label>
                        <input type="file" id="csvFileInput" accept=".csv,.txt,.tsv" onchange="loadCsvData(event)">
                        <div id="csvMessage" class="message"></div>
                    </div>
                    <p style="font-size: 12px; color: #718096;">Expected format: 2 or 3 columns (segment, value, std). Header is optional.</p>
                </div>
                
                <div id="manual-tab" class="tab-content">
                    <div class="data-table-container">
                        <table class="data-table" id="manualDataTable">
                            <thead>
                                <tr><th>Segment</th><th>Value</th><th>Std Dev</th></tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <button onclick="loadManualData()" style="margin-top: 10px;">Update from Table</button>
                </div>
            </div>

            <!-- Visualization Settings -->
            <div class="section">
                <h3 data-icon="🎨">Visualization</h3>
                <div class="flex-group">
                    <div class="form-group">
                        <label for="colorMap">Color Map:</label>
                        <select id="colorMap">
                            <option value="viridis">Viridis</option>
                            <option value="plasma">Plasma</option>
                            <option value="inferno">Inferno</option>
                            <option value="magma">Magma</option>
                            <option value="jet">Jet</option>
                            <option value="coolwarm">Cool-Warm</option>
                            <option value="RdYlBu">Red-Yellow-Blue</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="colorbarTitle">Colorbar Title:</label>
                        <input type="text" id="colorbarTitle" placeholder="e.g., Strain (%)">
                    </div>
                </div>
                 <div class="form-group">
                    <label>
                        <input type="checkbox" id="lockColorRange"> Lock Color Range (Min/Max)
                    </label>
                    <div class="flex-group" id="colorRangeInputs" style="display: none; margin-top: 5px;">
                        <input type="number" id="colorRangeMin" placeholder="Min" step="0.1">
                        <input type="number" id="colorRangeMax" placeholder="Max" step="0.1">
                    </div>
                </div>
                <div class="form-group">
                    <label>Line Width: <span id="lineWidthValue">2</span></label>
                    <input type="range" id="lineWidth" min="0.5" max="5" step="0.5" value="2">
                </div>
                <div class="form-group">
                    <label>Font Size: <span id="fontSizeValue">12</span></label>
                    <input type="range" id="fontSize" min="8" max="24" step="1" value="12">
                </div>
                <div class="form-group">
                    <label for="statDisplay">Text Display:</label>
                    <select id="statDisplay">
                        <option value="segment">Segment ID</option>
                        <option value="value">Value Only</option>
                        <option value="mean_std">Value ± Std</option>
                        <option value="both">ID & Value</option>
                    </select>
                </div>
                <div class="form-group">
                    <label><input type="checkbox" id="showLabels" checked> Show Segment Text</label>
                </div>
                <div class="form-group">
                    <label><input type="checkbox" id="showColorbar" checked> Show Colorbar</label>
                </div>
            </div>

            <!-- Plot Settings -->
            <div class="section">
                <h3 data-icon="⚙️">Plot Settings</h3>
                <div class="form-group">
                    <label for="plotTitle">Title:</label>
                    <input type="text" id="plotTitle" value="AHA 17-Segment Bull's Eye Plot">
                </div>
                <div class="form-group">
                    <label for="plotSubtitle">Subtitle:</label>
                    <input type="text" id="plotSubtitle" placeholder="Optional subtitle">
                </div>
                <div class="form-group">
                    <label>Plot Size: <span id="plotSizeValue">600</span>px</label>
                    <input type="range" id="plotSize" min="400" max="1000" step="50" value="600">
                </div>
            </div>

            <!-- Session & Export -->
            <div class="section">
                <h3 data-icon="💾">Session & Export</h3>
                <div class="form-group">
                    <label>Manage Session:</label>
                    <div class="btn-group">
                        <button onclick="saveState()">Save Session</button>
                        <button onclick="loadState()" class="btn-secondary">Load Session</button>
                        <button onclick="resetState()" class="btn-danger">Reset Defaults</button>
                    </div>
                    <div id="sessionMessage" class="message"></div>
                </div>
                <div class="form-group">
                    <label for="exportFormat">Export Format:</label>
                    <select id="exportFormat">
                        <option value="png">PNG</option>
                        <option value="svg">SVG</option>
                        <option value="pdf">PDF</option>
                    </select>
                </div>
                <div class="btn-group">
                    <button onclick="updateAndGeneratePlot()">🔄 Update Plot</button>
                    <button onclick="copyPlotToClipboard()" class="btn-secondary">📋 Copy</button>
                    <button onclick="exportPlot()" class="btn-secondary">📥 Export</button>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="plot-container" id="plotContainer">
                <div class="plot-placeholder">
                    <div>
                        <h3>AHA 17-Segment Plot</h3>
                        <p>Configure data and settings to generate</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- GLOBAL STATE ---
        let plotData = {};
        let currentPlot = null;

        // --- CONFIGURATION ---
        const segmentConfig = {
             1: { ring: 3, position: 0, totalInRing: 6, name: 'Basal Anterior' },
             2: { ring: 3, position: 1, totalInRing: 6, name: 'Basal Anteroseptal' },
             3: { ring: 3, position: 2, totalInRing: 6, name: 'Basal Inferoseptal' },
             4: { ring: 3, position: 3, totalInRing: 6, name: 'Basal Inferior' },
             5: { ring: 3, position: 4, totalInRing: 6, name: 'Basal Inferolateral' },
             6: { ring: 3, position: 5, totalInRing: 6, name: 'Basal Anterolateral' },
             7: { ring: 2, position: 0, totalInRing: 6, name: 'Mid Anterior' },
             8: { ring: 2, position: 1, totalInRing: 6, name: 'Mid Anteroseptal' },
             9: { ring: 2, position: 2, totalInRing: 6, name: 'Mid Inferoseptal' },
            10: { ring: 2, position: 3, totalInRing: 6, name: 'Mid Inferior' },
            11: { ring: 2, position: 4, totalInRing: 6, name: 'Mid Inferolateral' },
            12: { ring: 2, position: 5, totalInRing: 6, name: 'Mid Anterolateral' },
            13: { ring: 1, position: 0, totalInRing: 4, name: 'Apical Anterior' },
            14: { ring: 1, position: 1, totalInRing: 4, name: 'Apical Septal' },
            15: { ring: 1, position: 2, totalInRing: 4, name: 'Apical Inferior' },
            16: { ring: 1, position: 3, totalInRing: 4, name: 'Apical Lateral' },
            17: { ring: 0, position: 0, totalInRing: 1, name: 'Apex' },
        };
        
        // More comprehensive color maps
        const colorMaps = {
            viridis: ['#440154', '#482878', '#3e4a89', '#31688e', '#26828e', '#1f9e89', '#35b779', '#6dcd59', '#b4de2c', '#fde725'],
            plasma: ['#0d0887', '#46039f', '#7201a8', '#9c179e', '#bd3786', '#d8576b', '#ed7953', '#fb9f3a', '#fdca26', '#f0f921'],
            inferno: ['#000004', '#1b0c41', '#4a0c63', '#781c6d', '#a52c60', '#cf4446', '#ed6925', '#fb9a06', '#f7d03c', '#fcffa4'],
            magma: ['#000004', '#180f3d', '#440f76', '#721f81', '#9e2f7f', '#cd4071', '#f1605d', '#fd9567', '#fecf92', '#fcfdbf'],
            jet: ['#00007F', '#0000FF', '#007FFF', '#00FFFF', '#7FFF7F', '#FFFF00', '#FF7F00', '#FF0000', '#7F0000'],
            coolwarm: ['#3b4cc0', '#6788ee', '#9ec2f7', '#d1e6f9', '#f7f7f7', '#fddbc7', '#f4a582', '#d6604d', '#b2182b'],
            RdYlBu: ['#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4'].reverse()
        };

        // --- INITIALIZATION ---
        window.onload = function() {
            initializeManualTable();
            setupEventListeners();
            loadSampleData();
        };

        function initializeManualTable() {
            const tbody = document.querySelector('#manualDataTable tbody');
            tbody.innerHTML = '';
            for (let i = 1; i <= 17; i++) {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${i}</td>
                    <td><input type="number" id="value_${i}" step="any" placeholder="-" oninput="manualDataChanged()"></td>
                    <td><input type="number" id="std_${i}" step="any" placeholder="-" oninput="manualDataChanged()"></td>
                `;
                tbody.appendChild(row);
            }
        }

        function setupEventListeners() {
            // Slider value updates
            ['lineWidth', 'fontSize', 'plotSize'].forEach(id => {
                document.getElementById(id).oninput = e => document.getElementById(`${id}Value`).textContent = e.target.value;
            });

            // Auto-update plot on setting changes
            const autoUpdateElements = [
                'colorMap', 'lineWidth', 'fontSize', 'statDisplay', 'showLabels', 
                'showColorbar', 'plotTitle', 'plotSubtitle', 'plotSize', 'lockColorRange',
                'colorRangeMin', 'colorRangeMax', 'colorbarTitle'
            ];
            autoUpdateElements.forEach(id => {
                const element = document.getElementById(id);
                element.addEventListener(element.type === 'checkbox' ? 'change' : 'input', generatePlot);
            });
            
            // Toggle color range inputs
            document.getElementById('lockColorRange').addEventListener('change', (e) => {
                document.getElementById('colorRangeInputs').style.display = e.target.checked ? 'flex' : 'none';
            });
        }
        
        // --- DATA HANDLING ---
        function showMessage(elementId, text, isError = false, duration = 3000) {
            const el = document.getElementById(elementId);
            el.textContent = text;
            el.className = isError ? 'message error-message' : 'message success-message';
            el.style.display = 'block';
            setTimeout(() => { el.style.display = 'none'; }, duration);
        }

        function loadSampleData() {
            const sampleData = {"1":{"value":1.8,"std":0.1},"2":{"value":1.7,"std":0.05},"3":{"value":1.9,"std":0.12},"4":{"value":1.6,"std":0.08},"5":{"value":1.5,"std":0.1},"6":{"value":1.8,"std":0.09},"7":{"value":1.9,"std":0.11},"8":{"value":1.7,"std":0.06},"9":{"value":1.8,"std":0.1},"10":{"value":1.6,"std":0.07},"11":{"value":1.7,"std":0.08},"12":{"value":1.8,"std":0.09},"13":{"value":1.9,"std":0.1},"14":{"value":1.6,"std":0.05},"15":{"value":1.7,"std":0.08},"16":{"value":1.8,"std":0.1},"17":{"value":2.0,"std":0.12}};
            document.getElementById('jsonInput').value = JSON.stringify(sampleData, null, 2);
            loadJsonData();
        }

        function updateAndGeneratePlot() {
            const activeTab = document.querySelector('.tab-button.active').getAttribute('onclick').match(/'([^']+)'/)[1];
            if (activeTab === 'manual') loadManualData();
            // JSON and CSV load automatically
            generatePlot();
        }

        function loadJsonData() {
            const jsonInput = document.getElementById('jsonInput').value;
            try {
                const data = JSON.parse(jsonInput);
                processData(data);
                showMessage('jsonMessage', 'JSON data loaded successfully!');
            } catch (error) {
                showMessage('jsonMessage', 'Invalid JSON format: ' + error.message, true);
            }
        }
        
        function loadCsvData(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const text = e.target.result;
                    const rows = text.split('\n').filter(row => row.trim() !== '');
                    const data = {};
                    rows.forEach((row, index) => {
                        // Handle potential header
                        if (index === 0 && isNaN(parseFloat(row.split(/[\t,]/)[0]))) {
                            return; // Skip header row
                        }
                        const cols = row.split(/[\t,]/);
                        if (cols.length >= 2) {
                            const id = parseInt(cols[0].trim());
                            if (id >= 1 && id <= 17) {
                                data[id] = {
                                    value: parseFloat(cols[1].trim()),
                                    std: cols[2] ? parseFloat(cols[2].trim()) : 0
                                };
                            }
                        }
                    });
                    if (Object.keys(data).length === 0) throw new Error("No valid data found.");
                    processData(data);
                    showMessage('csvMessage', `Successfully loaded ${file.name}`);
                } catch (error) {
                    showMessage('csvMessage', 'Failed to parse file: ' + error.message, true);
                }
            };
            reader.readAsText(file);
        }

        function loadManualData() {
            const data = {};
            for (let i = 1; i <= 17; i++) {
                const valueInput = document.getElementById(`value_${i}`);
                const stdInput = document.getElementById(`std_${i}`);
                data[i] = {
                    value: valueInput.value ? parseFloat(valueInput.value) : null,
                    std: stdInput.value ? parseFloat(stdInput.value) : null
                };
            }
            processData(data);
        }

        function manualDataChanged() {
            // Optional: could auto-update the plot on manual input change.
            // For performance, we'll stick to the button click for now.
        }

        function processData(data) {
            plotData = {};
            for (let i = 1; i <= 17; i++) {
                const segmentData = data[i.toString()];
                if (segmentData && segmentData.value !== null && !isNaN(segmentData.value)) {
                    plotData[i] = {
                        value: parseFloat(segmentData.value),
                        std: parseFloat(segmentData.std || 0)
                    };
                } else {
                    plotData[i] = { value: null, std: 0 }; // Use null for missing data
                }
            }
            updateUIFromData();
            generatePlot();
        }

        function updateUIFromData() {
            // Update manual table
            for (let i = 1; i <= 17; i++) {
                const data = plotData[i];
                document.getElementById(`value_${i}`).value = data?.value ?? '';
                document.getElementById(`std_${i}`).value = data?.std ?? '';
            }
            // Update JSON input
            const jsonString = JSON.stringify(plotData, (key, value) => value === null ? undefined : value, 2);
            document.getElementById('jsonInput').value = jsonString;
        }

        // --- PLOT GENERATION ---
        function generatePlot() {
            if (Object.keys(plotData).length === 0) return;
            
            const plotSize = parseInt(document.getElementById('plotSize').value);
            const canvas = document.createElement('canvas');
            canvas.width = plotSize;
            canvas.height = plotSize;
            canvas.id = 'plotCanvas';
            
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, plotSize, plotSize);
            
            drawBullsEye(ctx, plotSize);
            
            const plotContainer = document.getElementById('plotContainer');
            plotContainer.innerHTML = ''; // Clear previous plot and legend
            plotContainer.appendChild(canvas);
            currentPlot = canvas;
            
            setupPlotInteractivity(canvas);
            
            if (document.getElementById('showColorbar').checked) {
                addColorbar(plotContainer);
            }
        }
        
        function drawBullsEye(ctx, size) {
            const center = size / 2;
            const maxRadius = size * 0.4;
            // Radii from center out: Apex -> Apical -> Mid -> Basal
            const ringRadii = [maxRadius * 0.25, maxRadius * 0.5, maxRadius * 0.75, maxRadius];
            
            const settings = getPlotSettings();
            
            ctx.lineWidth = settings.lineWidth;
            ctx.font = `${settings.fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const { minVal, maxVal } = getColorRange();
            
            Object.keys(segmentConfig).forEach(segmentId => {
                const id = parseInt(segmentId);
                const config = segmentConfig[id];
                const data = plotData[id];
                
                const color = (data && data.value !== null) ? getColor(data.value, minVal, maxVal) : '#E2E8F0'; // Gray for missing data

                if (config.ring === 0) { // Apex
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(center, center, ringRadii[0], 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                } else { // Annular segments
                    const innerRadius = ringRadii[config.ring - 1];
                    const outerRadius = ringRadii[config.ring];
                    
                    const anglePerSegment = (2 * Math.PI) / config.totalInRing;
                    // Offset to center segment 1 at the top
                    const angleOffset = -Math.PI / 2 - anglePerSegment / 2;
                    const startAngle = config.position * anglePerSegment + angleOffset;
                    const endAngle = startAngle + anglePerSegment;
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(center, center, outerRadius, startAngle, endAngle);
                    ctx.arc(center, center, innerRadius, endAngle, startAngle, true);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
                
                if (settings.showLabels && data) {
                    let labelX, labelY;
                     if (config.ring === 0) {
                        labelX = center;
                        labelY = center;
                    } else {
                        const midRadius = (ringRadii[config.ring - 1] + ringRadii[config.ring]) / 2;
                        const anglePerSegment = (2 * Math.PI) / config.totalInRing;
                        const angleOffset = -Math.PI / 2;
                        const midAngle = config.position * anglePerSegment + angleOffset;
                        labelX = center + midRadius * Math.cos(midAngle);
                        labelY = center + midRadius * Math.sin(midAngle);
                    }
                    
                    const brightness = getBrightness(color);
                    ctx.fillStyle = brightness > 128 ? 'black' : 'white';
                    
                    const labelText = formatLabel(id, data.value, data.std, settings.statDisplay);
                    
                    if (labelText.includes('\n')) {
                        const lines = labelText.split('\n');
                        lines.forEach((line, index) => {
                            ctx.fillText(line, labelX, labelY + (index - (lines.length - 1) / 2) * settings.fontSize);
                        });
                    } else {
                        ctx.fillText(labelText, labelX, labelY);
                    }
                }
            });
            
            // Draw Title and Subtitle
            if (settings.title) {
                ctx.font = `bold ${settings.fontSize + 4}px Arial`;
                ctx.fillStyle = 'black';
                ctx.fillText(settings.title, center, 30);
            }
            if (settings.subtitle) {
                ctx.font = `${settings.fontSize}px Arial`;
                ctx.fillStyle = '#666';
                ctx.fillText(settings.subtitle, center, 55);
            }
        }
        
        function formatLabel(id, value, std, displayMode) {
            if (value === null) return '';
            const valStr = value.toFixed(2);
            const stdStr = std.toFixed(2);
            switch (displayMode) {
                case 'segment': return id.toString();
                case 'value': return valStr;
                case 'mean_std': return `${valStr}±${stdStr}`;
                case 'both': return `${id}\n${valStr}`;
                default: return id.toString();
            }
        }

        // --- COLOR & LEGEND ---
        function getColor(value, min, max) {
            const colorMapName = document.getElementById('colorMap').value;
            const colors = colorMaps[colorMapName];
            if (max === min) return colors[Math.floor(colors.length / 2)];
            
            const ratio = Math.max(0, Math.min(1, (value - min) / (max - min)));
            const index = ratio * (colors.length - 1);
            const i1 = Math.floor(index);
            const i2 = Math.min(i1 + 1, colors.length - 1);
            const t = index - i1;
            
            const c1 = hexToRgb(colors[i1]);
            const c2 = hexToRgb(colors[i2]);
            
            const r = Math.round(c1.r * (1 - t) + c2.r * t);
            const g = Math.round(c1.g * (1 - t) + c2.g * t);
            const b = Math.round(c1.b * (1 - t) + c2.b * t);
            
            return `rgb(${r},${g},${b})`;
        }
        
        function addColorbar(container) {
            const { minVal, maxVal } = getColorRange();
            const colorbarTitle = document.getElementById('colorbarTitle').value;

            const legend = document.createElement('div');
            legend.className = 'legend';
            legend.style.right = '20px';
            legend.style.top = '20px';
            
            const canvas = document.createElement('canvas');
            const barWidth = 20;
            const barHeight = 150;
            const textWidth = 50;
            canvas.width = barWidth + textWidth;
            canvas.height = barHeight + 30; // space for title
            const ctx = canvas.getContext('2d');

            // Draw title
            if (colorbarTitle) {
                ctx.font = 'bold 12px Arial';
                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                ctx.fillText(colorbarTitle, canvas.width / 2, 10);
            }

            // Draw gradient bar
            const gradient = ctx.createLinearGradient(0, 15, 0, 15 + barHeight);
            const colorMap = colorMaps[document.getElementById('colorMap').value];
            colorMap.forEach((color, i) => {
                gradient.addColorStop(i / (colorMap.length - 1), color);
            });
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 15, barWidth, barHeight);

            // Draw labels
            ctx.font = '12px Arial';
            ctx.fillStyle = 'black';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(maxVal.toFixed(2), barWidth + 5, 15);
            ctx.fillText(minVal.toFixed(2), barWidth + 5, 15 + barHeight);
            ctx.fillText(((minVal + maxVal) / 2).toFixed(2), barWidth + 5, 15 + barHeight / 2);

            legend.appendChild(canvas);
            makeDraggable(legend);
            container.appendChild(legend);
        }

        // --- INTERACTIVITY ---
        function setupPlotInteractivity(canvas) {
            const tooltip = document.getElementById('tooltip');
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const segmentId = getSegmentFromCoords(x, y, canvas.width);
                
                if (segmentId && plotData[segmentId] && plotData[segmentId].value !== null) {
                    const data = plotData[segmentId];
                    tooltip.style.display = 'block';
                    tooltip.style.left = `${e.clientX + 15}px`;
                    tooltip.style.top = `${e.clientY}px`;
                    tooltip.innerHTML = `<b>Segment ${segmentId}</b>: ${segmentConfig[segmentId].name}<br>Value: ${data.value.toFixed(2)}<br>Std Dev: ${data.std.toFixed(2)}`;
                } else {
                    tooltip.style.display = 'none';
                }
            });
            
            canvas.addEventListener('mouseout', () => {
                tooltip.style.display = 'none';
            });
        }
        
        function getSegmentFromCoords(x, y, size) {
            const center = size / 2;
            const maxRadius = size * 0.4;
            const ringRadii = [maxRadius * 0.25, maxRadius * 0.5, maxRadius * 0.75, maxRadius];

            const dx = x - center;
            const dy = y - center;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= ringRadii[0]) return 17;

            let ring;
            if (distance <= ringRadii[1]) ring = 1;      // Apical
            else if (distance <= ringRadii[2]) ring = 2; // Mid
            else if (distance <= ringRadii[3]) ring = 3; // Basal
            else return null;

            const configForRing = Object.values(segmentConfig).find(c => c.ring === ring);
            if (!configForRing) return null;

            const totalInRing = configForRing.totalInRing;
            const anglePerSegment = (2 * Math.PI) / totalInRing;
            const angleOffset = -Math.PI / 2 - anglePerSegment / 2;
            
            let angle = Math.atan2(dy, dx) - angleOffset;
            if (angle < 0) angle += 2 * Math.PI;
            
            const position = Math.floor(angle / anglePerSegment);
            
            for (const id in segmentConfig) {
                const config = segmentConfig[id];
                if (config.ring === ring && config.position === position) {
                    return id;
                }
            }
            return null;
        }


        // --- SESSION MANAGEMENT ---
        function saveState() {
            try {
                const state = {
                    plotData: plotData,
                    settings: {}
                };
                const settingsIds = ['colorMap', 'colorbarTitle', 'lockColorRange', 'colorRangeMin', 'colorRangeMax', 'lineWidth', 'fontSize', 'statDisplay', 'showLabels', 'showColorbar', 'plotTitle', 'plotSubtitle', 'plotSize'];
                settingsIds.forEach(id => {
                    const el = document.getElementById(id);
                    state.settings[id] = el.type === 'checkbox' ? el.checked : el.value;
                });
                localStorage.setItem('ahaPlotterState', JSON.stringify(state));
                showMessage('sessionMessage', 'Session saved successfully!');
            } catch (error) {
                showMessage('sessionMessage', 'Failed to save session.', true);
            }
        }

        function loadState() {
            try {
                const stateString = localStorage.getItem('ahaPlotterState');
                if (!stateString) {
                    showMessage('sessionMessage', 'No saved session found.', true);
                    return;
                }
                const state = JSON.parse(stateString);
                
                // Load settings
                Object.keys(state.settings).forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        if (el.type === 'checkbox') {
                            el.checked = state.settings[id];
                        } else {
                            el.value = state.settings[id];
                        }
                        // Manually trigger updates for sliders and dependent elements
                        if (['lineWidth', 'fontSize', 'plotSize'].includes(id)) {
                             document.getElementById(`${id}Value`).textContent = el.value;
                        }
                        if (id === 'lockColorRange') {
                            document.getElementById('colorRangeInputs').style.display = el.checked ? 'flex' : 'none';
                        }
                    }
                });

                // Load data
                processData(state.plotData || {});
                showMessage('sessionMessage', 'Session loaded successfully!');
            } catch (error) {
                showMessage('sessionMessage', 'Failed to load session.', true);
            }
        }

        function resetState() {
            if (confirm("Are you sure you want to reset all data and settings?")) {
                localStorage.removeItem('ahaPlotterState');
                window.location.reload();
            }
        }
        
        // --- EXPORTING ---
        function exportPlot() {
            if (!currentPlot) return;
            const format = document.getElementById('exportFormat').value;
            const title = document.getElementById('plotTitle').value.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'aha_plot';
            
            if (format === 'png') {
                const link = document.createElement('a');
                link.download = `${title}.png`;
                link.href = currentPlot.toDataURL('image/png');
                link.click();
            } else if (format === 'svg') {
                // This is a placeholder for a more complex canvas-to-svg conversion
                alert("SVG export is a complex feature and not implemented in this version. Please choose PNG or PDF.");
            } else if (format === 'pdf') {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF();
                const imgData = currentPlot.toDataURL('image/png');
                pdf.addImage(imgData, 'PNG', 10, 10, 190, 190);
                pdf.save(`${title}.pdf`);
            }
        }
        
        function copyPlotToClipboard() {
            if (!currentPlot) {
                alert("Please generate a plot first.");
                return;
            }
            currentPlot.toBlob(function(blob) {
                navigator.clipboard.write([
                    new ClipboardItem({ 'image/png': blob })
                ]).then(function() {
                    alert('Plot copied to clipboard!');
                }).catch(function(error) {
                    console.error('Copy to clipboard failed:', error);
                    alert('Could not copy to clipboard. Your browser might not support this feature or require special permissions.');
                });
            });
        }

        // --- UTILITIES ---
        function switchTab(tabName) {
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`${tabName}-tab`).classList.add('active');
        }
        
        function getPlotSettings() {
            return {
                lineWidth: parseFloat(document.getElementById('lineWidth').value),
                fontSize: parseInt(document.getElementById('fontSize').value),
                showLabels: document.getElementById('showLabels').checked,
                statDisplay: document.getElementById('statDisplay').value,
                title: document.getElementById('plotTitle').value,
                subtitle: document.getElementById('plotSubtitle').value
            };
        }
        
        function getColorRange() {
            const isLocked = document.getElementById('lockColorRange').checked;
            const values = Object.values(plotData).map(d => d.value).filter(v => v !== null);
            let minVal, maxVal;

            if (isLocked) {
                minVal = parseFloat(document.getElementById('colorRangeMin').value);
                maxVal = parseFloat(document.getElementById('colorRangeMax').value);
                if (isNaN(minVal) || isNaN(maxVal)) {
                    isLocked = false; // fallback if inputs are bad
                }
            } 
            
            if (!isLocked) {
                minVal = values.length ? Math.min(...values) : 0;
                maxVal = values.length ? Math.max(...values) : 1;
            }
            return { minVal, maxVal };
        }

        function getBrightness(rgbColor) {
            const match = /rgb\((\d+), (\d+), (\d+)\)/.exec(rgbColor);
            if (!match) return 128; // Default for hex or other formats
            const [_, r, g, b] = match.map(Number);
            return (r * 299 + g * 587 + b * 114) / 1000;
        }

        function hexToRgb(hex) {
            let r = 0, g = 0, b = 0;
            if (hex.length == 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length == 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            return { r, g, b };
        }

        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            element.onmousedown = dragMouseDown;
            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }
            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }
    </script>
</body>
</html>

