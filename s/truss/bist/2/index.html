<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auxetic Cell Tessellation System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .slider-container {
            display: grid;
            grid-template-columns: 1fr 3fr 1fr;
            align-items: center;
            gap: 1rem;
        }
        canvas {
            cursor: grab;
            background-color: #f9fafb;
        }
        canvas:active {
            cursor: grabbing;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-4 overflow-hidden">

    <div class="w-full max-w-7xl bg-white rounded-xl shadow-lg p-6">
        <h1 class="text-2xl font-bold text-center text-gray-900 mb-6">Auxetic Cell Tessellation System</h1>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Canvas for plotting -->
            <div class="lg:col-span-2 rounded-lg border border-gray-200 aspect-[16/10]">
                <canvas id="plotCanvas"></canvas>
            </div>

            <!-- Controls -->
            <div class="flex flex-col justify-center space-y-4">
                <div class="text-lg font-semibold text-gray-800 mb-2">Cell Geometry</div>
                <div class="slider-container">
                    <label for="l0Slider" class="font-medium text-gray-700">L0</label>
                    <input type="range" id="l0Slider" min="200" max="1500" value="300" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <span id="l0Value" class="font-mono text-sm text-gray-600 text-center">300</span>
                </div>
                <div class="slider-container">
                    <label for="tSlider" class="font-medium text-gray-700">t</label>
                    <input type="range" id="tSlider" min="0" max="150" value="60" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <span id="tValue" class="font-mono text-sm text-gray-600 text-center">60</span>
                </div>
                <div class="slider-container">
                    <label for="sSlider" class="font-medium text-gray-700">s</label>
                    <input type="range" id="sSlider" min="0" max="150" value="80" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <span id="sValue" class="font-mono text-sm text-gray-600 text-center">80</span>
                </div>
                <div class="slider-container">
                    <label for="aSlider" class="font-medium text-gray-700">a</label>
                    <input type="range" id="aSlider" min="0" max="300" value="120" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <span id="aValue" class="font-mono text-sm text-gray-600 text-center">120</span>
                </div>
                <div class="slider-container">
                    <label for="thetaSlider" class="font-medium text-gray-700">&theta;</label>
                    <input type="range" id="thetaSlider" min="0" max="90" value="60" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <span id="thetaValue" class="font-mono text-sm text-gray-600 text-center">60°</span>
                </div>
                
                <hr class="my-4 border-gray-300"/>
                <div class="text-lg font-semibold text-gray-800 mb-2">Tessellation Pattern</div>
                
                <div class="slider-container">
                    <label for="wSlider" class="font-medium text-gray-700">Columns</label>
                    <input type="range" id="wSlider" min="1" max="8" value="3" step="1" class="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer">
                    <span id="wValue" class="font-mono text-sm text-gray-600 text-center">3</span>
                </div>
                
                <div class="slider-container">
                    <label for="hSlider" class="font-medium text-gray-700">Rows</label>
                    <input type="range" id="hSlider" min="1" max="6" value="2" step="1" class="w-full h-2 bg-green-200 rounded-lg appearance-none cursor-pointer">
                    <span id="hValue" class="font-mono text-sm text-gray-600 text-center">2</span>
                </div>
                
                <hr class="my-4 border-gray-300"/>
                <div class="text-lg font-semibold text-gray-800 mb-2">Pattern Options</div>
                
                <div class="slider-container">
                    <label for="offsetSlider" class="font-medium text-gray-700">Row Offset</label>
                    <input type="range" id="offsetSlider" min="0" max="100" value="50" step="5" class="w-full h-2 bg-purple-200 rounded-lg appearance-none cursor-pointer">
                    <span id="offsetValue" class="font-mono text-sm text-gray-600 text-center">50%</span>
                </div>
                
                <div class="slider-container">
                    <label for="rotationSlider" class="font-medium text-gray-700">Cell Rotation</label>
                    <input type="range" id="rotationSlider" min="0" max="360" value="0" step="15" class="w-full h-2 bg-red-200 rounded-lg appearance-none cursor-pointer">
                    <span id="rotationValue" class="font-mono text-sm text-gray-600 text-center">0°</span>
                </div>
                
                <div class="mt-4 p-3 bg-gray-50 rounded-lg">
                    <div class="text-sm text-gray-600">
                        <strong>Tessellation Info:</strong><br>
                        Total Cells: <span id="totalCells">6</span><br>
                        Pattern Type: <span id="patternType">Hexagonal</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Element Selection ---
        const canvas = document.getElementById('plotCanvas');
        const ctx = canvas.getContext('2d');
        const sliders = {
            l0: document.getElementById('l0Slider'),
            t: document.getElementById('tSlider'),
            s: document.getElementById('sSlider'),
            a: document.getElementById('aSlider'),
            theta: document.getElementById('thetaSlider'),
            w: document.getElementById('wSlider'),
            h: document.getElementById('hSlider'),
            offset: document.getElementById('offsetSlider'),
            rotation: document.getElementById('rotationSlider'),
        };
        const values = {
            l0: document.getElementById('l0Value'),
            t: document.getElementById('tValue'),
            s: document.getElementById('sValue'),
            a: document.getElementById('aValue'),
            theta: document.getElementById('thetaValue'),
            w: document.getElementById('wValue'),
            h: document.getElementById('hValue'),
            offset: document.getElementById('offsetValue'),
            rotation: document.getElementById('rotationValue'),
        };
        
        // --- Color Definitions ---
        const colors = {
            set1: { line: '#6b7280', point: '#10b981', stroke: '#047857' }, // Gray, Emerald
            set2: { line: '#60a5fa', point: '#3b82f6', stroke: '#1d4ed8' }, // Blue
            set3: { line: '#fca5a5', point: '#ef4444', stroke: '#b91c1c' },  // Red
        };

        // --- Pan & Zoom State ---
        let scale = 0.4;
        let panOffset = { x: 0, y: 0 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };

        /**
         * Draws a single geometric system (points and lines) on the canvas.
         */
        function drawSystem(ctx, points, colorSet, alpha = 1.0) {
            const { p0, p1, p2, p3, p4, p5 } = points;

            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.lineWidth = 2 / scale;
            ctx.strokeStyle = colorSet.line;
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y);
            ctx.moveTo(p4.x, p4.y); ctx.lineTo(p5.x, p5.y);
            ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
            ctx.moveTo(p4.x, p4.y); ctx.lineTo(p3.x, p3.y);
            ctx.moveTo(p2.x, p2.y); ctx.lineTo(p3.x, p3.y);
            ctx.stroke();

            // Dashed connection line
            ctx.beginPath();
            ctx.setLineDash([5 / scale, 5 / scale]);
            ctx.moveTo(p1.x, p1.y); ctx.lineTo(p4.x, p4.y);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw points
            Object.values(points).forEach((pt) => {
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, 4 / scale, 0, 2 * Math.PI);
                ctx.fillStyle = colorSet.point;
                ctx.fill();
                ctx.strokeStyle = colorSet.stroke;
                ctx.lineWidth = 1.5 / scale;
                ctx.stroke();
            });
            
            ctx.restore();
        }

        /**
         * Transforms a set of local points by rotating and then translating them.
         */
        function transformSystem(localPoints, origin, angleRad) {
            const transformed = {};
            const cosA = Math.cos(angleRad);
            const sinA = Math.sin(angleRad);

            for (const key in localPoints) {
                const p = localPoints[key];
                const rotatedX = p.x * cosA - p.y * sinA;
                const rotatedY = p.x * sinA + p.y * cosA;
                transformed[key] = {
                    x: rotatedX + origin.x,
                    y: rotatedY + origin.y
                };
            }
            return transformed;
        }

        /**
         * Calculate the bounds of a triangular cell to determine spacing
         */
        function calculateCellBounds(L0, t, s, a, thetaDeg) {
            const thetaRad = thetaDeg * Math.PI / 180;
            const theta60Rad = (60 - thetaDeg) * Math.PI / 180;

            const localPoints = {
                p0: { x: 0, y: 0 }, p1: { x: t, y: 0 }, p4: { x: t + s, y: 0 }, p5: { x: L0, y: 0 },
                p2: { x: t + a * Math.cos(thetaRad), y: a * Math.sin(thetaRad) },
                p3: { x: (t + s) + (a - s * Math.cos(theta60Rad)) * Math.cos(thetaRad), y: (a - s * Math.cos(theta60Rad)) * Math.sin(thetaRad) }
            };

            // Create the full cell by transforming the three systems
            const system1 = transformSystem(localPoints, {x: 0, y: 0}, 0);
            const system2 = transformSystem(localPoints, system1.p5, 120 * Math.PI / 180);
            const system3 = transformSystem(localPoints, system2.p5, 240 * Math.PI / 180);

            // Find bounds of the complete cell
            const allPoints = [...Object.values(system1), ...Object.values(system2), ...Object.values(system3)];
            
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            allPoints.forEach(p => {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            });

            return {
                width: maxX - minX,
                height: maxY - minY,
                centerX: (minX + maxX) / 2,
                centerY: (minY + maxY) / 2,
                minX, maxX, minY, maxY
            };
        }

        /**
         * Create a single auxetic cell at a given position with rotation
         */
        function createCell(localPoints, position, cellRotation = 0) {
            // Apply cell-level rotation first, then translate
            const rotatedLocal = transformSystem(localPoints, {x: 0, y: 0}, cellRotation);
            
            const system1 = transformSystem(rotatedLocal, position, 0);
            const system2 = transformSystem(rotatedLocal, {
                x: position.x + rotatedLocal.p5.x, 
                y: position.y + rotatedLocal.p5.y
            }, 120 * Math.PI / 180);
            const system3 = transformSystem(rotatedLocal, {
                x: position.x + system2.p5.x - position.x, 
                y: position.y + system2.p5.y - position.y
            }, 240 * Math.PI / 180);

            return { system1, system2, system3 };
        }

        // --- Main Drawing Logic ---
        function draw() {
            // Get current values from sliders
            const L0 = parseFloat(sliders.l0.value);
            const t = parseFloat(sliders.t.value);
            const s = parseFloat(sliders.s.value);
            const a = parseFloat(sliders.a.value);
            const thetaDeg = parseFloat(sliders.theta.value);
            const w = parseInt(sliders.w.value, 10);
            const h = parseInt(sliders.h.value, 10);
            const offsetPercent = parseFloat(sliders.offset.value);
            const cellRotationDeg = parseFloat(sliders.rotation.value);

            // Update value displays
            values.l0.textContent = L0.toFixed(0);
            values.t.textContent = t.toFixed(0);
            values.s.textContent = s.toFixed(0);
            values.a.textContent = a.toFixed(0);
            values.theta.textContent = `${thetaDeg.toFixed(0)}°`;
            values.w.textContent = w;
            values.h.textContent = h;
            values.offset.textContent = `${offsetPercent.toFixed(0)}%`;
            values.rotation.textContent = `${cellRotationDeg.toFixed(0)}°`;
            
            // Update constraints
            sliders.t.max = L0 / 2;
            sliders.s.max = L0 / 2;
            if (t + s > L0) {
                sliders.s.value = L0 - t;
            }

            // Update info display
            document.getElementById('totalCells').textContent = w * h;
            document.getElementById('patternType').textContent = offsetPercent > 0 ? 'Hexagonal' : 'Rectangular';

            // --- Point Calculations ---
            const thetaRad = thetaDeg * Math.PI / 180;
            const theta60Rad = (60 - thetaDeg) * Math.PI / 180;
            const cellRotationRad = cellRotationDeg * Math.PI / 180;

            // Calculate the base local system
            const localPoints = {
                p0: { x: 0, y: 0 }, p1: { x: t, y: 0 }, p4: { x: t + s, y: 0 }, p5: { x: L0, y: 0 },
                p2: { x: t + a * Math.cos(thetaRad), y: a * Math.sin(thetaRad) },
                p3: { x: (t + s) + (a - s * Math.cos(theta60Rad)) * Math.cos(thetaRad), y: (a - s * Math.cos(theta60Rad)) * Math.sin(thetaRad) }
            };

            // Calculate cell bounds for spacing
            const bounds = calculateCellBounds(L0, t, s, a, thetaDeg);
            
            // --- Canvas Setup ---
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(panOffset.x, panOffset.y);
            ctx.scale(scale, scale);

            // --- Draw Tessellated Pattern ---
            const cellSpacingX = bounds.width * 0.8; // Slight overlap for better connection
            const cellSpacingY = bounds.height * 0.7;

            for (let row = 0; row < h; row++) {
                for (let col = 0; col < w; col++) {
                    // Calculate position with hexagonal offset
                    const offsetX = (row % 2) * (cellSpacingX * offsetPercent / 100);
                    const posX = col * cellSpacingX + offsetX;
                    const posY = row * cellSpacingY;

                    // Alternate cell orientations for better tessellation
                    const alternatingRotation = ((row + col) % 2) * Math.PI / 6; // 30° alternation
                    const totalRotation = cellRotationRad + alternatingRotation;

                    // Create cell at calculated position
                    const cellPosition = { x: posX, y: posY };
                    const cell = createCell(localPoints, cellPosition, totalRotation);
                    
                    // Vary opacity based on position for depth effect
                    const alpha = 0.7 + 0.3 * Math.sin((row + col) * 0.5);
                    
                    // Draw the cell systems
                    drawSystem(ctx, cell.system1, colors.set1, alpha);
                    drawSystem(ctx, cell.system2, colors.set2, alpha);
                    drawSystem(ctx, cell.system3, colors.set3, alpha);
                }
            }

            ctx.restore();
        }

        // --- Coordinate Transformation for Mouse ---
        function screenToWorld(screenPos) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (screenPos.x - rect.left - panOffset.x) / scale,
                y: (screenPos.y - rect.top - panOffset.y) / scale
            };
        }

        // --- Event Listeners ---
        Object.values(sliders).forEach(slider => slider.addEventListener('input', draw));
        
        window.addEventListener('load', () => {
            const rect = canvas.parentElement.getBoundingClientRect();
            panOffset.x = rect.width / 2;
            panOffset.y = rect.height / 2;
            draw();
        });
        window.addEventListener('resize', draw);

        // Pan and Zoom Listeners
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStart.x = e.clientX - panOffset.x;
            dragStart.y = e.clientY - panOffset.y;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                panOffset.x = e.clientX - dragStart.x;
                panOffset.y = e.clientY - dragStart.y;
                draw();
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = 1.1;
            const mouseWorldPos = screenToWorld({ x: e.clientX, y: e.clientY });
            
            let newScale;
            if (e.deltaY < 0) { // Zoom in
                newScale = scale * zoomFactor;
            } else { // Zoom out
                newScale = scale / zoomFactor;
            }

            panOffset.x = e.clientX - canvas.getBoundingClientRect().left - mouseWorldPos.x * newScale;
            panOffset.y = e.clientY - canvas.getBoundingClientRect().top - mouseWorldPos.y * newScale;
            
            scale = newScale;
            draw();
        });

    </script>
</body>
</html>